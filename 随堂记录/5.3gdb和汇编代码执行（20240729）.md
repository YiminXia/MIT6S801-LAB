# gdb与汇编代码执行

[toc]

接下来我们来看一下实际的汇编代码，上面是C语言源码，这是一个有累加功能的简单函数

![img](.assets/image%20(294).png)

累加从1到n的所有数字，并返回结果。下半部分是汇编代码，很简单。如果你自己实际在自己的电脑上写C代码并编译它，你得到的汇编代码可能差别很大。这里有很多原因，有一些原因我们之后会讲，有一些原因是因为编译器。现代编译器有很多优化，当它们将你的C代码编程成汇编指令时，就会有很多不同。例如，当你使用gdb进行debugging时，有时你会遇到gdb告诉你某些变量被优化掉了，这表示编译器认为它不需要这个变量。

上图中代码都很直观，先将寄存器a0值移动到t0中，之后将寄存器a0置0，之后每个循环都将将t0加到a0上，直到t0变为0为止。

>学生问：我想知道.section，.global，.text分别是什么意思？
>
>TA：global表示你可以从其他files中调用这个函数，让我们看下def.h文件，这个文件你们之后会十分的熟悉。这个文件基本包含了kernel中你可能使用的所有函数。在我的defs.h文件中，最后包含了这些函数的定义。所以.global确保这些函数可以在其他files中被调用。
>
>.text表示这些是code，如果你还记得xv6书中的图3.4的话：
>
>![](.assets/image%20(300).png)
>
>每个进程的page table中有一个区域是text，汇编代码中的text表明这部分是code，并且位于page table的text区域中，text中保存的就是代码。

如果你发现自己对kernel比较感兴趣，在编译完内核之后，你可以查看kernel.asm文件，这个文件是完整的xv6的kernel的汇编版本。文件中每一行左边的数字表明的是这条指令会在内存中的哪个位置，这个信息非常有用。在汇编代码中还能看到函数的label，以及它们是在哪声明的。这些信息对于我们调试代码很有帮助。

>学生问：.asm文件与.S文件的区别？
>
>TA：我不是百分百的确定，但是它们都是汇编文件，.asm文件中包含大量的额外标注，但是.S文件中没有。通常使用编译器将C源码编译成.S文件是不含有这些额外标注的，如果你想知道我们如何获取.asm文件，仔细看目录中的makefile文件吧。

现在我们跳回第一个函数`sum_to`，我们会看到如何使用gdb调试这个函数。我们这里有两个窗口，第一件事是启动并运行QEMU；如下图所示：

![img](.assets/image%20(307).png)

此时需要在另一个窗口启动gdb

![img](.assets/image%20(343).png)

如果你在gdb中输入tui enable命令可以打开一个源码展示窗口。

我们应该注意到现在的代码都位于kernel中，没有在用户空间中的，所以我们目前没有设置断点的烦恼（PS：如果想在用户空间的代码打断点，需要导入新的符号表文件）。所以我在`sum_to`函数中设置一个断点，然后按`c`继续运行代码，然后会运行到这个函数，代码的运行在断点处停住。

![img](.assets/image%20(290).png)

如上图所示：gdb窗口的左上角是PC：0x80065e2（program counter）即程序计数器，我们现在看到此时的PC值为0x80065e2。我们此时查看kernel.asm文件并搜索这个0x80065e2地址，我们可以看到这个地址就是sum_to函数的起始地址。

![img](.assets/image%20(344).png)

所有内核地址看起来都是0x8000这样的数字，你可以直接查找kernel.asm文件并找到该地址对应的的汇编代码，然后分析问题的原因，然后再在相应的地址上打断点。

在gdb中输入layout asm，可以在tui窗口中看到所有的汇编指令。在gdb中输入layout reg，我们会看到所有寄存器的信息。我们现在有3个tui窗口了，使用`focus reg`命令可以切换tui窗口。这时我滑动鼠标滑轮，这个tui窗口会随之滚动。

此时在寄存器窗口，我们可以看到t0：0x80002840，a0：0x5的值；

![img](.assets/image%20(210).png)

接着我们使用s执行一条汇编指令(mv t0, a0)之后，此时寄存器t0的值变成了a0的值，也就是5。在寄存器窗口，更新了的寄存器会被高亮出来

![img](.assets/image%20(317).png)

如果我们在gdb中输入enter回车键，相当于再次执行上一次的gdb命令；

如果你关心你设置了哪些断点，使用命令`info breakpoints`查看所有的设置了的断点。你可以查看这个断点被命中了几次，下图所示`sum_to`断点被命中1次：

![img](.assets/image%20(272).png)

如果你不想用register window但却想查看寄存器信息，使用`info reg, info registers, i registers`查看寄存器信息。

>学生问：你怎么打开这么多窗口的。
>
>TA：我通过tmux打开的（本课程无关，不做记录，这里不是tui窗口，指的是tab窗口，使用xterm moba爱开多少开多少）
>
>学生问：为啥这里显示的是汇编代码而不是C源码？
>
>TA：这是因为这个函数`sum_to`本身就是用汇编代码实现的，自然就没没有C源码与之关联。这里我输入delete会删除之前所有的断点。然后我在C源码中（demo）中，然后按c继续并运行，然后再命中断点之后我再次输入`layout split`就会显示C源码与汇编。如果只输出layout source那就只会显示C源码。layout reg输入之后会显示寄存器的窗口。但不幸的是，我至今没有发现一个方法，可以同时显示C语言，汇编，寄存器三个窗口。
>
>学生问：在C源码文件中，我将断点打在某一行上，C源码某一行可能对应多条指令，断点实际会定在哪条指令呢？
>
>TA：断点会设置在第一条指令上。

gdb还提供了内置手册，使用apropos tui命令查看。



