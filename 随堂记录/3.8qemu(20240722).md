# qemu

[toc]

当你考虑QEMU时，你不应该将它想成一个C程序。你应该将它想成下图这样，一个真正的主板。

![img](.assets/image%20(98).png)

上图是一个我办公室里的主板，它可以启动xv6。当你通过QEMU来运行你的内核时，你应该认为你的内核也是运行在这样一个主板上。你的主板有一个开关，一个RISC-V处理器，还有支持外设的空间，比如说一个支持以太网的网络接口，一个PCI-E插槽，一些RAM芯片。这些构成了一个你可以在上面编程的电脑，而xv6负责管理这个主板，所以你脑子中应该有这么一张图。

下图是一个RISC-V处理器的结构图：

![img](.assets/image%20(100).png)

这里有很多cores，实际上是4个cores，这里还有L2-cache，连接DRAM的连接器，各种连接外部世界的方式，比如说UART0，一端连接了键盘，另一端连接了显示器。连接了时钟的接口，clock generation。我们后续会讨论细节。

- 4个核：U54 Core 1-4
- L2 cache：Banked L2
- 连接DRAM的连接器：DDR Controller
- 各种连接外部设备的方式，比如说UART0，一端连接了键盘，另一端连接了terminal。
- 以及连接了时钟的接口：Clock Generation

但是这里基本上就是RISC-V处理器的所有组件，你通过它与实际的硬件交互。

实际上抛开一些细节，通过QEMU模拟的计算机系统或者说计算机主板，与这里这个由SiFive生产的计算机主板非常相似。本来想给你们展示一下这块主板的，但是我刚刚说过它在我的办公室，而我已经很久没去过办公室了，或许它已经吃了很多灰了。重要的是你需要记住，当你运行QEMU时，基本上就跟运行在硬件上一样，只是这样的东西被QEMU用软件实现了而已。

那么，什么叫QEMU模拟了RISC-V处理器？

从字面上看，正如我刚才说的QEMU是一个大的开源的C程序，你可以直接下载或者git clone。但是在其内部其实是一个无限for循环。

* 这个for循环一直在读指令，读RISC-V的指令，4字节的指令，8字节的指令；
* 然后解析这些RISC-V指令，找出这些指令的opcode；我们之前在看kernel.asm的时候，看过一些操作码的二进制版本。通过解析，或许可以知道这是一个ADD指令，或者是一个SUB指令。
* 然后通过软件执行这些指令。

这基本上就是QEMU的工作了，对于每一个core，都运行上面这么一个for循环。

![img](.assets/image%20(102).png)

除此之外，这个for循环还需要维护所有寄存器的状态。所以QEMU会有以C语言声明的类似于X0，X1寄存器等等。

![img](.assets/image%20(99).png)

当QEMU在执行这么一条指令，比如`ADD a0, 7, 1`，这条指令将7跟1相加，然后将结果存储在a0寄存器中，所以在这个例子中，寄存器X0会是7。

![img](.assets/image%20(103).png)

之后QEMU会执行下一条指令，并持续不断的执行指令。QEMU处理模拟了所有的非特权指令，还模拟了所有的特权指令，所以这就是QEMU的工作原理。对于你们来说，你们只需要知道代码运行在QEMU上，就跟跑在6.004那门课里面的RISC-V处理器上是一样的。

这里有什么问题吗？

>学生问：我想知道，QEMU有没有什么欺骗硬件的实现，比如说overlapping instruction ?
>
>教授答：并没有，真正的CPU运行在QEMU下层。当你运行QEMU时，很有可能你是运行在一个x86处理器上，这个x86处理器本身会做各种处理，比如顺序解析指令，所以QEMU对你来说就是个C语言程序。
>
>学生提问：那多线程呢?程序能真正跑在4个core上吗？还是只能跑在一个core上？如果可以跑在多个core上，那么QEMU是不是有多线程？
>
>教授答：我们在Athena上使用的QEMU还有你们下载的QEMU。它们会使用多线程。QEMU在内部通过多线程实现并行处理。所以当QEMU在模拟4个core的时候，它是并行模拟这4个core。我们在后面有个实验会演示这里如何工作的。所以（QEMU模拟多个Core时）是真的在不同的CPU的core上进行并行运算。
>
>







