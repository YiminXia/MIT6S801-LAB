# 上节课回顾

[toc]

今天4个主题：

* isolation：隔离性是设计操作系统组织结构的驱动力。
* kernel/user mode：这两种模式用来隔离操作系统内核和用户应用程序。
* system call：系统调用是用户程序转化成内核执行的基本方法。
* 看下上述这些机制在XV6中的简单实现。

![img](.assets/image%20(5).png)

 接下来让我们回顾一下上节课，你脑子里会出现下面这张图片：

* 一些应用程序，shell，echo，find或者你自己实现的其他应用程序，这些都运行在一个操作系统上。
* 操作系统同时对一些硬件资源进行抽象，比如disk和CPU。
* 操作系统与应用程序之间的接口，通常被称为system call interface。我们这门课看到的接口都是UNIX风格的接口。

![img](.assets/image%20(51).png)

lab1即util lab更多关注的是使用这些接口，而后续的课程我们将研究这些接口是如何实现的。

在我们进一步讨论之前，让我向你们提一些问题来开始今天的课程。util lab中你最感兴趣的点是哪个？

我先自己回答这个问题。在实现lab之后，我使用xargs的频率比之前多了不少。我之前使用一个跟xargs差不多的方法，但是做完了util lab试验之后，我发现xargs比我之前使用的方式更方便快捷。

接下来是老师抽查学生的实验情况，没啥可记录的。