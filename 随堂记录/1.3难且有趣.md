



研究操作系统是一个难且有趣的挑战。

学习操作系统比较困难的原因是，内核的编程环境比较困难。当你在编程时，比如修改`kernel`，扩展`kernel`，编写一个新`kernel`，你其实是在为他人编写的应用程序提供一个可运行的基础设施。别人写的应用程序下面运行的是操作系统，但当我们在构建一个操作系统时，操作系统下面运行的硬件`hardware`。在本课程中，我们使用QEMU硬件模拟器来模拟CPU和计算机，这样会好很多，但这仍然是一个困难的编程环境。

操作系统另一个难且有趣的原因是，当你在设计一套操作系统时，需要解决一系列矛盾的事情。

* （efficient --- abstract）你想要你的操作系统高效。高效通常意味着操作系统在离硬件近的`low-level`进行操作；而易于使用则要求你的操作系统需要为应用程序提供抽象的`high-level`的可移植接口。
* （powerful --- simple）我们想要提供一个`powerful`的操作系统，这样操作系统可以分担应用程序的负担。但同时我们也想要`simple`的接口，即我们不想程序员看到特别复杂，难于理解的接口。道理很简单，如果他们不理解这些接口，他们就不会使用这些接口。所以，这里要提供一个简单的接口，同时又包含了`powerful`的功能。

Robert教授：kernel的代码总是有特殊的权限，kernel的特殊权限能直接访问各种硬件，比如kernel可以直接访问磁盘，这是用户程序无法做到的。所以当你执行一个普通的函数调用时，它是没有对硬件的特殊权限的。然而，当你触发系统调用到内核中，kernel中系统调用的实现会被赋予特殊权限，因此，它可以修改各种敏感的受保护的硬件资源，比如直接访问硬盘。

* （flexible --- secure）你希望给应用程序尽可能多的灵活性，所以你需要非常灵活的接口。但是另一方面，你必须在某种程度上限制应用程序，因为你也需要考虑安全性。我们想给程序员自由，但又不可能给予其全部自由，我们不希望程序直接访问硬件，干扰到其他应用程序，或者干扰到操作系统本身。

另一件有趣的事情是，操作系统提供了很多的特性与服务，它们趋向于交互，有时，这种交互的方式很奇特，这值得我们思考一下。举个例子：`open`与`fork`，这俩之间也交互，一个应用程序使用`open`打开一个文件并得到一个文件描述符，接着这个应用程序使用`fork`创建了一个新的进程，即一个拷贝了当前进程的副本。这里需要思考一下，对于一个真正的拷贝，上面的文件描述符在子进程中也存在，并且也可以使用。所以在这里，一个通过`open`获取的文件描述符，与`fork`以这种有趣的方式交互。所以必须有人来搞清楚，子进程到底应不应该也能够使用这个文件描述符，答案是肯定的，可以使用。



两个问题，这里值记录问题2：对于一些例如python的高阶编程语言（高阶指的是离自然语言更近，低阶是指离机器语言更近比如C，汇编）它们是直接调用系统调用，还是内部对系统调用进行了封装？

Robert教授：很多高阶编程语言确实离系统调用比较远，这是一个事实，部分原因是很多编程语言想要提供可以在多个操作系统上运行的可移植的环境，所以它们不能依赖特定的操作系统的某个系统调用。所以，对于这个问题的答案我认为是，如果你使用了python，你在某种程度上与系统调用接口隔离了。但是，在python内部，最终还是要执行系统调用来完成相应的工作。当然，python与许多编程语言通常都有方法能够直接访问系统调用。