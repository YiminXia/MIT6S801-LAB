# 操作系统隔离性

[toc]

## 1、应用程序之间的隔离性

我们先简单说一下隔离性（isolation）,以及介绍它为什么很重要。

核心思想比较简单，我们有很多应用程序，shell，echo，find等等。如果你的shell进程有个bug，此时正在运行prime代码，此时shell不应用影响其他进程。举个反例，如果shell出现问题时，kill掉了其他进程，这将十分糟糕。**这就是为啥你希望在不同进程之间提供很强的隔离性**。

## 2、应用程序与操作系统之间的隔离性

类似的，操作系统某种程度上为所有的应用程序服务，当你在应用程序里面写了个bug，你肯定不希望操作系统因此crash掉，比如说，当你向操作系统传递了一个奇怪的arguments，你肯定希望操作系统可以很好的处理这种情况，**因此在应用程序与操作系统之间也应该存在很好的隔离性**。

## 3、multiplexing与Memory isolation

现在请大家问自己一个问题，如果没有操作系统会怎么样？或者操作系统只是一些library库文件。比如python通过import os基本上就将整个操作系统load到你的应用程序中来了。那么现在，我们有一个shell，并且我们引用了代表操作系统的库。同时，我们有一些其他的应用程序，echo。

![img](.assets/image%20(37).png)

因为没有操作系统，所以这些应用程序会直接跟hardware打交道，所以如下图，这里有一个CPU，这里再有一个CPU，这里还有个disk，应用程序可以直接跟disk blocks（扇区）打交道，也许还应该有个Memory，应用程序也可以直接跟物理Memory打交道。所以在应用程序与hardware之间的abstract layer（硬件抽象层）消失了。

![img](.assets/image%20(11).png)

上图从隔离性角度看，并不是一个很好的设计，因为你可以看到，这种设计是如何破坏隔离性的。**我们都知道操作系统的一个目的就是运行多个应用程序，**下面是我画的一个物理内存，应用程序的text与data都存储在物理内存上，其中一段物理内存被shell使用，另一段物理内存被echo使用。

![img](.assets/image%20(30).png)

很明显看到两个应用程序之间是没有边界的。此时如果echo将某个值x存储在地址1000的位置，而这个位置是属于shell进程的。此时echo应用进程就over write shell进程的物理内存。这种情况十分难以debug与定位问题。我们希望的是不同应用进程之间存在**Memory isolation**，这样一个应用进程就不会over write另一个应用进程的物理内存了。

**使用操作系统的一个原因，甚至可以说是重要的原因，即实现应用程序的multiplexing与Memory isolation。**如果你不通过操作系统是很难满足这两点的。所以将操作系统设计成一个库，并不是一种常见的设计，你或许会在一些实时操作系统中看到这样的设计，因为在这些操作系统中，应用程序是互相信任的。但是在其他大部分操作系统中都会强制实现硬件资源的隔离。

我们从隔离的角度看一下UNIX接口，我们会发现接口是被精心的设计的，以便于实现multiplexing与Memory isolation。**实现方式是，接口通过对硬件资源进行抽象（abstract hardware resource）来实现这种强隔离性的**。

![img](.assets/image%20(33)%20(1).png)

### 3.1 process是对CPU的抽象

举个例子，之前我们通过fork接口创建process进程，首先进程并不是CPU，但是进程对应了CPU，进程使得你可以在CPU上完成计算任务。所以你懂得，应用程序不能直接与CPU交互，只能与process进行交互，kernel会完成不同的process在物理CPU上的切换。所以操作系统不是直接将物理CPU提供给应用程序，而是将process提供给应用程序，process抽象了物理CPU。这样kernel就可以使多个应用程序复用一个CPU或者多个CPU。

> 学生问：你说的process抽象了CPU，意思是一个process使用一部分CPU，另一个process使用另一部分CPU吗？
>
> 教授答：我真实想表达的意思是，我们实验中使用的RISC-V架构的CPU实际上有4个core，所以你可以同时运行4个process,即每个process占用一个core。操作系统此时要做的事情是，假如你有7个或8个应用程序，此时操作系统会让这些cores进行分时复用（time multiplexing），比如让一个process在一个core上运行100ms然后unload，再让该core load另一个process 运行100ms。通过这种方式让每个应用程序都不会连续运行超过100ms。
>
> 学生问：OK，也就是说多个进程无法同时使用CPU的同一个core吧。
>
> 教授答：是的，这里是分时复用，core运行一个process一段时间，在运行另一个process一段时间。

### 3.2 exec是对Memory的抽象

接下来我们讨论exec，exec抽象了Memory，当我们使用exec系统调用时候，我们会传入一个文件名，而这个文件名对应了一个应用程序的内存镜像。内存镜像包含了一个应用程序的指令，全局数据等。应用进程可以逐步的扩大自己的内存，比如扩大自己的data segment通过sbrk接口。但是应用程序没有直接与物理Memory交互的权限，比如应用程序不能直接访问物理Memory的1000-2000的地址。

不能直接访问物理内存的原因是，操作系统会提供Memory isolation并控制物理内存，操作系统在应用程序与硬件资源（这里指物理Memory）之间提供了一个中间层。exec是这样一种系统调用，表明应用程序无法直接访问物理内存。

![img](.assets/image%20(14).png)

### 3.3 file是对disk的抽象

另一个例子是file，file抽象的是disk，UNIX中不允许应用程序直接访问disk或者disk blocks。在UNIX中唯一与storage system（存储系统）交互的方式就是通过files。你可以读写files，命名一个file等等。之后，操作系统需要做的事情是如何将这个file与disk blocks进行映射，确保一个disk block只出现在一个file中，还要确保用户A不能操作、读写用户B的文件。通过file的抽象，可以实现不同用户之间的files，以及同一个用户不同的进程之间的files的强隔离性。

![img](.assets/image%20(48).png)

上图这些接口都是你们在上一个lab中使用过的UNIX系统调用接口，或许你们已经看出来了，这些接口都是被精心设计过的，它们抽象了计算机的硬件资源。操作系统实现这些接口目的就是能在多个应用程序之间multiplexing计算机的硬件资源并提供strong isolation。

> 学生提问：更复杂的内核会不会尝试将进程调度到同一个CPU的core上来减少cache miss？
>
> 教授答：有一种机制叫cache affinity。现在的操作系统的确非常复杂，我们后续课程介绍高性能网络的时候，会介绍更多这方面的内容。
>
> 学生提问：XV6代码中，操作系统让process复用CPU的部分在哪？
>
> 教授答：很多源码文件都是与复用有关的，但是最相关的应该是proc.c文件，大约两到三周之后的课程中会有一个topic是介绍复用的，我们到时会看到大量的细节并展示操作系统是如何进行复用的，本节课的内容更多是为其他的知识开个头，因为我们总得从某个地方开始吧。



## 模糊点：

1、怎么理解process是对CPU的抽象？

答：首先理解，操作系统搞这么多抽象的目的是什么，是为了让应用程序“间接使用”硬件资源，所以应用程序怎么才能使用CPU的计算资源，答案是process这个抽象，同理应用程序通过exec这个系统调用“间接试用”了物理内存，通过files“间接使用”了disk。

2、process是对CPU的抽象，指的是`struct proc`这个结构体是对CPU的抽象吗？

