# kvminithart函数

[toc]

## 随堂笔记

kvminit函数返回了，在main函数中，我们运行到了kvminithart函数

![img](.assets/image%20(196).png)

这个函数首先先写SATP寄存器，kernel_pagetable变量来自kvminit函数的第一行。所以这里可以理解成，内核告诉MMU使用刚刚设置好的Page table。

在这条指令执行之前（w_satp函数对应的指令），不存在Page table所以也不存在什么地址翻译。执行完这条指令之后，程序计数器（program counter）增加了4。而之后的下一条指令被执行时，程序计数器会被会被内存中Page table翻译。

所以这条指令执行时刻是一个非常重要的时刻，因为整个地址翻译从这条指令执行之后开始生效，之后每一个使用到的内存地址都可能被映射到不同的物理地址。因为在这条指令之前，我们使用的都是物理内存地址，纸条指令之后Page table开始生效，所有的内存地址都变成了另一个含义，即虚拟内存地址。

这里能正常工作的原因是值得注意的。因为下一跳指令的地址已经是虚拟内存地址了，不再是物理内存地址了。比如下一跳指令的地址是0x80001110就是个虚拟内存地址

![img](.assets/image%20(203).png)

这里为啥可以正常工作呢？因为在kernel page的映射关系中，这一段的物理内存地址与虚拟内存地址是完全相等的。所以在我们打开虚拟地址翻译硬件之后，地址翻译硬件还是会将VA翻译成等值的PA。所以，我们最终还是能够通过内存虚拟地址执行到正确的指令，因为经过地址翻译0x80001110还是对应0x80001110。

编写内存管理的一个难点就是，一旦你执行了一个SATP这种指令，你相当于加载了一个page table到SATP寄存器中，此时整个世界都改变了（上下文切换了）。此刻之后，每一个地址都会被你新加在的page table所翻译，所以一旦你的page table设置错误了会发生什么？

> 学生A答：会覆盖kernel data
>
> 学生B答：会产生page fault

是的，因为page table设置错了，VA很可能无法被翻译，kernel直接回停止运行并panic。









## 模糊点







