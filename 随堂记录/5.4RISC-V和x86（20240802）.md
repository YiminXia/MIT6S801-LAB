# RISC-V与x86

[toc]

## 随堂记录



接下来我们看一下之后lab相关的内容。同时也是对文档的一次回顾，我相信勤奋的同学在上课前已经看完了一遍了。

![img](.assets/image%20(315).png)

6.004那门课加上本课程的课前准备，大家应该对上面这张表很熟悉了。这张表是关于寄存器的，寄存器是CPU或者处理器周围预先定义的可以用来存储数据的位置。**寄存器之所以重要，是因为汇编代码不是在memory上执行，而是在寄存器上进行操作**。所以我们执行add，sub时，我们是对寄存器进行操作。所以你们通常会看到汇编代码的形式是，我们通过load将数据加载到寄存器中，这些数据可能来自memory也可能来自其他寄存器。这里的load是广义上的，不是指load指令。之后我们对寄存器进行操作，如果我们对操作结果感兴趣的话，我们可将结果store在某个地方，可以是memory中的某个地方或另一个寄存器。上述就是寄存器的常用使用方法。

![img](.assets/image%20(282).png)

寄存器是用来计算和读取数据最快的方式。这就是为什么寄存器很重要，也是为什么我们更喜欢使用寄存器而不是memory。当我们调用函数的时候，你可能会看到a0-a7寄存器，通常我们在谈到寄存器时候，都使用寄存器的ABI名称，使用ABI不仅清晰与标准，还有一点就是汇编代码里面也是用的ABI名称。第一列中的寄存器名字并不是很重要。它唯一重要的使用场景是RISC-V指令的compressed版本，基本上来说RISC-V的指令是64bit的，但是compressed版本只有16bit，因此该版本使用的寄存器也更少即x8-x15寄存器。这里我猜你们会有个疑问，为啥s1寄存器会与其他s寄存器分开，我自己的猜测是s1寄存器在compressed模式下是可用的，但是s2-s11却不行。除了Compressed Instruction，寄存器都是通过它们的ABI名字来引用。

a0-a7寄存器是用来作为函数的参数。但是如果一个函数有超过8个参数，那样的话我们需要使用memory了。这其实就是个例子，我们能使用寄存器的时候，是不会使用memory的，除非不得不使用。

表单中第四列，saver列，这个在讨论寄存器时候也相当重要，它有两个可能的值Caller，Callee。这俩caller与callee我自己也经常弄混。最简单的记录方法是：

* caller saved register在函数调用的时候不会保存
* callee saved register在函数调用的时候保存

![img](.assets/image%20(299).png)

什么意思呢？caller saved register可能会被其他函数复写，比如说函数A调用函数B，任何被函数A使用的寄存器属于caller saved register，函数B可能重写这些寄存器。我想返回地址寄存器就是个很好的例子，因为ra寄存器是caller saved。这很重要，因为每个函数都要使用返回地址。当函数A调用函数B，B是可以重写return Address寄存器中的值，这就是为什么它是caller saved。callee saved register使用的惯例我们很熟悉，帧指针很重要，这些寄存器在函数调用之间保留。对于任何一个caller saved register，进行调用的函数需要注意这些寄存器。如果是callee saved register，则被调用函数需要保存这些寄存器的值。

如果你们还记得的话，所有的寄存器都是64bit，它们有64位可以放东西。各种各样的数据类型都会被改造，以便可以放进64bit的寄存器中。比如说我们有一个32bit的整数，取决于整数是不是有符号的，会通过在前面补32个0或者1来使得这个整数变成64bit并存在这些寄存器中。

> 学生问：返回值可以放在a1寄存器中吗？
>
> TA：是的，这是个好问题。理论上是可以的，如果一个函数返回一个long long也就是128bit类型的返回值，我们可以把它放到一对寄存器中。这也同样适用于函数的参数。所以，如果返回值超过了一个寄存器的长度，超过了64bit，当我们说word长是，指的是64bit长度。如果我们有两倍于指针字大小的东西，我们可以把它放入一对寄存器中。因此同样的惯例也适用于放回地址，我们可以将返回值保存在a0和a1。但是如果你只将返回值放在a1寄存器，我认为会出错。
>
> 学生提问：为什么寄存器是分开的，s1寄存器与其他s寄存器分开，为什么a寄存器在它们中间，有什么意义吗？
>
> TA：我之前提过的，有一个压缩版的RISC-V指令，它的大小是16bit而不是64bit，你可以用它来使代码在内存中占用更少的memory空间。而当你使用这些16bit的指令时，你只能使用x8-x15寄存器。所以我认为s1与s2-s11是分开的，因为他们想要明确s1可以再compressed version指令模式下使用，而s2-s11则不可以在该模式下使用。
>
> 学生提问：除了frame pointer还有stack pointer，我不认为我们需要更多的callee saved register。
>
> TA：但是我们却有很多callee saved register比如s0-s11,我认为它们是提供给编译器而不是程序员使用。在一些特定的场景下，你会想要确保一些数据在函数调用之后仍然能够保存，这个时候编译器可以选择使用s寄存器。我要提醒一下，这些浮点寄存器，浮点算数，据我说知你们在这节课上不会接触它们，所以也不用担心。







## 模糊点

