# 地址空间（Address Spaces）

[toc]

## 随堂记录



创造虚拟内存的一个出发点是你可以通过它实现隔离性。如果你正确的设置了page table，并且通过代码对它进行正确的管理，那么原则上你可以实现强隔离。

![image (141).png](.assets/image%20(141).png)

我们希望每个用户程序都被装进一个盒子里，这样他们不会彼此影响。**类似的，我们也想让他们与内核操作系统相互独立，上图操作系统也在一个盒子里**。这是我们期望达到的隔离性。

DRAM芯片中保存了应用程序的数据与代码。内存中某一部分是内核，某一部分是shell，某一部分是cat。如下图所示，我们这里说的是物理内存，地址从0开始到一个很大很大的地址结束。

![image (175).png](.assets/image%20(175).png)

假设shell的物理内存位于地址1000-2000之间。cat出现了程序错误，将内存地址1000，也就是shell的起始地址加载到内存中并执行`sd $7,(a0)`这相当于将7写入1000。

![img](.assets/image%20(153).png)

**现在cat进程弄乱了shell进程的内存镜像**。我们想要某种机制，将不同程序之间的内存隔离开来，以避免上述情况的发生。一种方法就是地址空间（Address Spaces）。

Address Spaces的基本概念很简单，**我们希望所有的应用进程，包括kernel都有自己的专属Address Space**。如下图所示：

![img](.assets/image%20(140).png)

此时cat再次运行命令`sd $7,(a0)`,a0的值1000指的是cat自己的地址空间的地址，不是shell的了，cat在根本上不具备引用除自己之外的物理地址。

所以接下来的问题是，我们如何复用DRAM芯片实现上述设计。实现Address spaces方法最常用的是使用page table



## 模糊点：

**1、虚拟内存可以比物理内存大，也可以比物理内存小。**

比如32bit的操作系统，VA的长度为32bit，那样32位操作系统最大支持4GB内存，现在是个物理DRAM芯片都大于4GB吧。

RISC-V的寄存器是64bit，其VA的长度为64bit，但是最高25bit为空置的，只有后39bit被使用，所以理论上RISC-V最高支持2^39byte内存即512GB，但是现在还没有哪个物理DRAM芯片搞这么大的



2、<font color='red'>这里又引出了一个旧问题，即32位操作系统，64位操作系统，这个多少位操作系统指的是什么呢？VA的长度吗？</font>





3、<font color='red'>kalloc，kalloc保存了空余page的列表，如果这个列表耗尽了，kalloc会返回一个空指针，kernel会妥善处理并将结果返回给应用程序。没有内存分给你了，整个机器都没有内存了。内核的一部分工作就是优雅的处理这种事情，优雅指的是向用户返回一个错误消息，而不是直接崩溃了。</font>