# Lab:locks

[toc]

在此次实验中，你会获得重新设计代码而带来并发性的经验。常见的现象是，锁的争用会导致多核机器并发性下降。为了改进并发性经常需要修改数据结构，修改锁的策略进而减少锁的争用。您将为xv6内存分配器和块缓存执行此操作。

>在写代码之前，你先把xv6 book中下面这些内容看完：
>
>* Chapter6：“Locking”与响应的代码。
>* Section3.5：“Code：Physical memory allocator"
>* Section8.1 到 8.3：“Overview","Buffer cache layer",和"Code:buffer cache。

```bash
$ git fetch
$ git checkout lock
$ make clean
```



## Memory allocator(moderate）

用户程序`user/kalloctest`强调xv6的memory allocator：三个进程增加或者缩小它们的地址空间，导致会经常调用`kalloc`跟`kfree`。`kalloc`跟`kfree`又都需要获取`kmem.lock`。`user/kalloctest`会打印 (as "#fetch-and-add")acquire函数中尝试获取lock的次数，kmem.lock与其他几种锁都有这种打印。acquire函数中的循环尝试获取锁的次数，可以粗糙的衡量锁竞争的烈度。在完成该实验之前，你运行`kalloctest`之后的输出看起来如下：

```bash
$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem: #fetch-and-add 83375 #acquire() 433015
lock: bcache: #fetch-and-add 0 #acquire() 1260
--- top 5 contended locks:
lock: kmem: #fetch-and-add 83375 #acquire() 433015
lock: proc: #fetch-and-add 23737 #acquire() 130718
lock: virtio_disk: #fetch-and-add 11159 #acquire() 114
lock: proc: #fetch-and-add 5937 #acquire() 130786
lock: proc: #fetch-and-add 4080 #acquire() 130786
tot= 83375
test1 FAIL
```

Acquire为每个锁维护为该锁获取的调用计数，以及Acquire中的循环尝试设置锁但失败的次数。Kalloctest调用一个系统调用，使内核输出kmem和bcache锁（这是本实验的重点）和5个争用最多的锁的计数。如果存在锁争用，则acquire函数中循环迭代的次数将会很大。系统调用返回kmem和bcache锁的循环迭代次数的总和。

为了这个实验，你最好使用一个专门的空闲的机器而且得是多核的，如果你用的机器还敢别的事情，kalloctest的输出打印会相当离谱。你可以使用专门的Athena workstation，或者你自己的笔记本，不能使用dialup machine。

kalloctest程序引起lock contention的根因是kalloc函数中的的freelist被一个lock保护。要消除锁争用，必须重新设计memory allocator，以避免使用单个锁和列表。基本思想是为每个CPU维护一个freelist，每个freelist都有自己的锁。不同CPU上的allocations和frees可以并行运行，因为每个CPU将对不同的freelist进行操作。主要的挑战来自于当一个CPU的freelist耗尽了，但是别的CPU的freelist还有空余，此时一个CPU必须从其他CPU那里偷，这里可能会引起锁竞争，但是这种竞争基本上是罕见。

>你的任务是为每个CPU都实现一个freelist，当一个CPU的freelist耗尽了，从其他CPU偷。你必须给你的lock以kmem开头命名。也就是说，你得给你创建的每个lock都调用下initlock函数，还得将以kmem开头的锁名字当做入参传进入。运行`kalloctest`用户态程序看下你的实现是否减少了lock contention现象。
>
>为了检测是否可以完全分配完memory，你还得运行`usertests`跟`sbrkmuch`程序，你的输出打印得跟下面这张图差不多才行，要很明显看到kmem-locks的锁竞争已经大幅减少。确保`usertests`的所有测试用例都可以通过。`make grade`命令测试kalloctests是否通过。
>
>```
>$ kalloctest
>start test1
>test1 results:
>--- lock kmem/bcache stats
>lock: kmem: #fetch-and-add 0 #acquire() 42843
>lock: kmem: #fetch-and-add 0 #acquire() 198674
>lock: kmem: #fetch-and-add 0 #acquire() 191534
>lock: bcache: #fetch-and-add 0 #acquire() 1242
>--- top 5 contended locks:
>lock: proc: #fetch-and-add 43861 #acquire() 117281
>lock: virtio_disk: #fetch-and-add 5347 #acquire() 114
>lock: proc: #fetch-and-add 4856 #acquire() 117312
>lock: proc: #fetch-and-add 4168 #acquire() 117316
>lock: proc: #fetch-and-add 2797 #acquire() 117266
>tot= 0
>test1 OK
>start test2
>total free number of pages: 32499 (out of 32768)
>.....
>test2 OK
>$ usertests sbrkmuch
>usertests starting
>test sbrkmuch: OK
>ALL TESTS PASSED
>$ usertests
>...
>ALL TESTS PASSED
>$
>```

一些提示：

* 你可以使用常量NCPU，在kernel/param.h
* 让freerange将所有空闲内存分配给运行freerange的CPU。
* 函数cpuid返回当前的core编号，但是只有在中断关闭时调用它并使用它的结果才是安全的。您应该使用push_off（）和pop_off（）来关闭和打开中断。
* 请查看kernel/sprintf.c中的snprintf函数，了解字符串格式化的想法。不过，将所有锁命名为“kmem”是可以的。