# 自旋锁的实现（一）

[toc]

接下来我们来看一下如何实现自旋锁。锁的特性就是只有一个进程可以获取锁，在任何时间点不能有超过一个锁的持有者。

我们先来一个有问题的锁的实现，这样能更好的理解我们需要面对的挑战是什么。`acquire(struct lock * l)`这个函数`acquire`里面有个死循环while(1)，循环判断`if(l->locked == 0)`就是l的locked字段是否是0，如果是0就表示当前这个锁没有持有者，当前的acquire的调用进程可以获取锁。之后我们设置`l->lock = 1`表示持有锁。最后返回。

![img](.assets/image%20(492).png)

如果locked字段不为0，那么当前对于acquire的调用就不能获取锁，就会一直spin。也就是说，程序在死循环中不能的重复执行，直到锁的持有者调用了release并将locked设置为0。

这个实现有什么问题呢？

> 学生回答：两个进程可能同时读到锁的locked字段为0；

是的，这里会有race condition

![img](.assets/image%20(468).png)

我们画个时间图理解一下，CPU0与CPU1同时到达A语句，然后它俩又同时到达B语句，也就是说它俩都acquire到了锁。

为了解决上面的问题，我们又很多种方法。但是最常见的方法是依赖于一个特殊的硬件指令。这个特殊的硬件指令会保证一次`test-and-set`操作的原子性。在RISC-V上，这个特殊的指令就是amoswap(atomic memory swap)。这个指令会接收3个参数，分别是address，寄存器r1，寄存器r2。这条硬件指令先锁定住address，将该address中的值保存在一个临时变量tmp中，然后将寄存器r1中的值写入到该address上，之后将tmp的值写入寄存器r2中，之后对address解锁。

![img](.assets/image%20(475).png)

通过这里加锁，可以确保address中的值被保存在r2中，而r1中的数据被保存在address上面，并且这一些列操作具有原子性（因为是一条指令）。大多数处理器都有这样的指令，因为这是实现锁的一种方便的方式。

这里我们通过将一个软件锁转变为硬件锁最终实现了锁的原子性。不同处理器的具体实现可能会非常不一样，处理器的指令集通常像是一个说明文档，它不会有具体实现的细节，具体的实现依赖于内存系统是如何工作的，比如说：

* 多个处理器共用一个内存处理器，内存处理器可以支持这里的操作，比如让内存处理器给一个特定的address加锁，然后让一个CPU执行后面的2-3个指令，然后再解锁。因为所有的处理器都需要通过内存处理器来完成读写，所以内存控制器可以对操作进行排序与加锁。
* 如果内存位于一个共享的总线上，那么需要总线控制器（bus arbiter）来支持。总线控制器需要以原子的方式执行多个内存操作。
* 如果处理器有缓存，那么缓存一致性协议会怎么样？会保证对于持有了我们想要更新的数据的cache line只有一个写入者，相应的处理器会对cache line加锁，完成两个操作。

硬件原子操作的实现很多种。但是基本上的实现都是，先对address加锁，读出原始的数据，写入新数据，然后返回原始数据（注，也就是实现了atomic swap）。

接下来我们看一下如何使用上面这个atomic swap指令来实现自旋锁，看下xv6中acquire与release的实现。先看spinlock.h文件

![img](.assets/image%20(547).png)

struct spinlock结构体定义很简单，包含了locked字段，其他两个字段name与cpu更多是为了debug。

接下来看acquire函数的实现，位于spinlock.c文件中

![img](.assets/image%20(538).png)

在函数中有一个while循环，就是我们刚说的test-and-set循环。实际上C标准库已经定义了这些操作，所以C标准库中有一个函数`__sync_lock_test_and_set`函数，它的具体行为与我们描述的是一样的，不同的处理器需要实现这个行为。因为大部分处理器都有test_and_set硬件指令，所以这个函数的实现比较直观。

我们看下kernel.asm文件，看看RISC-V是怎么实现的atomic swap操作的。

![img](.assets/image%20(471).png)

amoswap指令用到寄存器a5，输入跟输出都是a5.....这里比较复杂，总的来说，就两种情况一种情况我们跳出循环，一种情况我们继续执行循环。

C代码就简单很多：

* 如果锁没有被持有，那么此时locked字段是0，然后我们会调用test-and-set操作，将原始值0读取出来，将1写入locked字段，并且返回locked字段的原始值，也就是0。如果返回0，那么意味着循环结束了，我们成功拿到锁了。
* 如果锁已经被持有，那么此时locked字段是1，然后test-and-set操作会干什么，将原始值1读出来放在一边，然后将新1写入到这个位置，这不会改变任何东西，因为locked之前的原始值就是1，然后`__sync_lock_test_and_set`函数返回1，此时while内部判断式成立，程序会持续spin。直到locked字段被设置为0。

接下来看下release的实现，继续看kernel.asm中关于release的汇编代码

![img](.assets/image%20(528).png)

可以看出release也是用了atomic swap操作指令，将0写入s1（s1表示的是locked字段的地址，相当于将locked设置为0)。它基本确保了lk->locked或者l->locked中写入0操作是个原子操作。

![img](.assets/image%20(452)%20(1)%20(1)%20(1).png)







