# xv6中UART模块对于锁的使用

[toc]

接下来我们看一下xv6的代码，通过代码来理解锁是如何在xv6中工作的。我们首先查看一下uart.c，在上节课介绍中断的时候我们提到了这里的锁，我们现在具体来看一下。因为我们现在对锁有了了解，接下来展示一些更有趣的细节。

从代码上看UART只有一个锁。

![img](.assets/image%20(466).png)

所以你可以认为对于UART模块来说，现在是一个coarse-grained lock的设计。这个锁保护了UART的传输缓存；写指针；读指针。当我们传输数据时，写指针会指向传输缓存的下一个空闲槽位，而读指针指向的是下一个需要被传输的槽位。这是我们对于并行运算的一个标准设计，它叫做消费者，生产者模式。

所以现在有一个buffer，一个w写指针，一个r指针。读指针的内容需要被显示，写指针接收来自于例如printf的数据。我们前面已经了解到了锁可以有多个角色。

锁可以保护数据结构某些不变的特性，例如r读指针需要追赶w写指针；从r读指针到w写指针之间的数据是用来发送到console的，从写指针到读指针之间的是空闲槽位。锁帮助我们保护buffer这些特性不变。

![img](.assets/image%20(526).png)

我们来看下uartputc函数中的代码，代码位于uart.c文件中

![img](.assets/image%20(494)%20(1).png)

uartputc函数做的第一件事是获取锁，查看buffer是否有空闲的槽位，如果有就把一个character放进buffer，然后给w写指针加1；调用uartstart函数；然后release锁，最后返回。

如果有两个进程同时调用uartputc函数，这个锁会保证第一个进程的一个character会保存在第一个空闲槽位，第二个进程的character会保存在第二个槽位，这俩character不会碰巧出现在同一个槽位。这是一个锁帮助我们避免race  condition的典型例子，因为加入没有锁的话，第二个进程的character可能会覆盖了第一个进程的character了（注，两个进程的写指针都指向了同一个空闲的槽位锁导致）。

接下来我们看一下uartstart函数

![img](.assets/image%20(536).png)

如果uart_tx_w不等于uart_tx_r，那么buffer不为空，这说明buffer中有一些字符需要被处理。此时锁（注，uartputc函数中获取的uart_tx_lock）保证了，在处理完buffer中的数据之前，缓存中的数据不会被覆盖。

最后，锁确保了一个时间只有一个CPU上的进程可以写入UART的寄存器，THR。所以这里锁确保了硬件寄存器只有一个写入者。

当UART硬件完成传输，会产生一个中断。通过uartstart函数中代码我们知道了，uartstart的调用者获得锁之后会确保不会有多个进程同时像THR寄存器写数据。但是UART中断本身确实可以与调用printf的进程并行执行。如果一个进程调用了printf函数，该进程运行在CPU0上面，CPU1是可以处理UART所产生的中断的，因为CPU1此时可能没活干正处于空闲，那么CPU1也会调用uartstart函数。因为我们想要确保对于THR寄存器只有一个写入者，同时也确保传输缓存的特性不变（注，这里指的是在uartstart中对于uart_tx_r指针的更新），我们需要在中断处理函数中也获取锁。

![img](.assets/image%20(449).png)



所以在xv6中，驱动的bottom部分（注，也就是中断处理程序）与驱动的up部分（注，uartputc函数）可以完全的并行运行。所以中断处理程序也需要获取锁。我们接下来会介绍，在实现锁的时候，为了确保这里能正常工作还是有点复杂的。

（注，下面问答来自课程结束部分）

> 学生提问：UART的缓存中，读指针是不是总是会落后于写指针？
>
> Frans教授：从读指针到写指针之间的字符是要显示的字符，UART会逐次的将读指针指向的字符在显示器上显示，同时printf可能又会将新的字符写入到缓存。读指针总是会落后于写指针直到读指针追上了写指针，这时两个指针相同，并且此时缓存中没有字符需要显示。