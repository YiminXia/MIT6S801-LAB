# 锁的特性与死锁

[toc]

通常锁有三种作用，理解它们可以帮助你更好的理解锁。

* 锁可以避免丢失更新。如果你回想我们之前在kalloc.c中的例子，丢失更新是指我们丢了某个物理page在kfree函数中的更新，如果没有锁，在出现race condition的时候，内存page不会被加到freelist中。但是加上锁之后，我们就不会丢失这里的更新。

* 锁可以打包多个操作，使其具有原子性。就是我们之前说的，加锁与释放锁之间的代码是critical section。在critical section的所有操作会都会作为一个原子操作执行。

* 锁可以维护共享数据结构的不变性。共享数据结构如果不被任何进程修改的话是会保持不变的。如果某个进程acquire lock并且做了更新操作，共享数据结构的不变性就会被破坏，但是release lock之后，数据的不变性又得以恢复了。

  我们可以想一下freelist这个例子（freelist就是个共享的数据结构），free pointer指向了下一个可用的内存page，所有的可用的内存page都在一个单链表上，但是在kfree函数中间那里，多个指针指向了freelist的开头，如果没有锁的话，freelist的不变性会被交织破坏。freelist并不复杂，对于一些更复杂的数据结构可能会更好的帮助你理解锁的作用。

![img](.assets/image%20(550).png)

即使是前面介绍的kfree函数这么一个简单的场景，上面的这些锁的作用都有体现。

接下来我们来看一下locks带来的一些缺点。我们已经知道了锁可以被用来解决一些正确性相关的问题，比如避免race condition等。但是如果不恰当的使用锁，可能会带来一些问题，最明显的就是死锁（deadlock）问题。

一个死锁最简单的场景就是：首先acquire一个锁，然后进入到critical section；在critical section中又acquire同一个锁。接下来会发生什么呢？第二次acquire会成功吗？第二次acquire必然不会成功，因为必须等到第一次acquire状态被release了才能继续执行，但是不继续执行的话又走不到第一个release，所以程序就一直卡在这了。这就是一个死锁。

![img](.assets/image%20(472).png)

这就是deadlock一个最简单的例子，xv6会探测这样的死锁，如果xv6看到同一个进程多次acquire同一个锁，就会触发一个panic。

当有多个锁的时候，场景会更加有趣。假设现在我们有两个核CPU1，CPU2。CPU1现在执行`rename("d1/x", "d2/y")`，CPU2此时执行`rename("d2/a", "d1/b")`。这里CPU1将文件从d1移动到d2，CPU2正好将文件从d2移动到d1。

我们假设我们按照参数的顺序来acquire锁，那么CPU1会先acquire到d1的锁，如果程序是真正的在并发执行的话，此时CPU2会先acquire到d2的锁。之后CPU1会继续尝试acquire到d2的锁，此时会成功吗？显然不会，因为此时CPU2已经acquire到了d2的锁，所以CPU1就会停在这个位置等到CPU2 release掉d2的锁。

再来看下CPU2的情况，此时CPU2正在尝试acquire到d1的锁，也不会成功，理由跟CPU1无法acquire到d2的锁的原因一样。这也是死锁的一个例子，有时候这种场景也被称为deadly embrace。这里的死锁就没那么容易探测了。

![img](.assets/image%20(537).png)

这种情况的解决方案也很简单，如果你有多个锁，你需要对锁进行排序。所有的操作都必须按照相同的顺序acquire锁。

![img](.assets/image%20(569).png)

所以对于系统设计者来说，你需要对所有锁对象进行全局排序。例如对于上面那个例子来说，d1的锁应该一直排在d2前面，这意味着我们在执行rename操作的时候，我们总是应该先获取排序靠前目录的锁，然后获取排序靠后目录的锁。如果对于所有的锁有了一个全局的排序，这里的死锁就不会出现了。

在设计一个操作系统的时候，定义一个全局的锁的顺序会有一些问题。如果一个模块m1中方法g调用了另一个模块m2中的方法f，那么m1中的方法g需要知道m2的方法f使用了哪些锁。为如果m2使用了一些锁，那么m1的方法g必须集合f和g中的锁，并形成一个全局的锁的排序。这意味着在m2中的锁必须对m1可见，这样m1才能以恰当的方法调用m2。

但是这样又违背了代码抽象的原则。在完美的情况下，代码抽象要求m1完全不知道m2是如何实现的。但是不幸的是，具体实现中，<font color=red>m2内部的锁需要泄露给m1，这样m1才能完成全局锁排序</font>。所以当你设计一些更大的系统时，锁使得代码的模块化更加的复杂了。

>学生提问：有必要对所有锁进行排序吗？
>
>教授回答：在上面的例子中，这取决于f与g是否共用了一些锁。你会看到多种锁的排序，而不是只有一个总得排序，这是因为一些锁与其他锁没有任何关系，它们永远不会在一个操作中被acquire。如果两组锁不可能在同一个操作中被acquire，那么这两组锁的排序就是完全独立的。所以没有必要对所有的锁进行一个全局的排序，但是所有的函数需要对共同使用的一些锁进行一个排序。