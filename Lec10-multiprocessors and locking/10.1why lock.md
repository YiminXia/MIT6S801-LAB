# 为什么需要锁

[toc]

今天的课程的内容是锁。这节课偏向于理论介绍，并且或许会与其他课程中有关锁的内容重合，不过这节课更关注在内核和操作系统中使用的锁。

首先，我们来看一下为什么我们需要锁？故事要从应用程序想要使用CPU多核开始。使用多核可以带来性能上的提升，如果一个应用程序运行在多个核上，并且执行系统调用，那么内核需要能够处理并行的系统调用。如果系统调用并行的运行在多个CPU核上，那么它们可能访问内核中共享的数据结构。

到目前为止，xv6中就很多共享的数据结构，例如proc，ticks和上节课说的buffer cache等等。当并行的访问数据结构时，例如一个核在写入数据，一个核在读取数据，我们需要使用锁来协调对于共享数据结构的访问，以确保数据的一致性。所以，我们需要锁来控制并确保共享数据是正确的。

但是实际情况有些令人失望。我们希望通过并行来获得高性能，想要并行的在不同的CPU核上执行系统调用。但是如果这些系统调用使用了共享数据，我们又需要使用锁，而锁又会使得这些系统调用串行执行，所以锁最后反过来又限制了性能。

![img](.assets/image%20(463)%20(1)%20(1)%20(1).png)

所以现在我们处于一个尴尬的境地，从正确性角度考虑我们需要锁，但是从性能角度看，锁限制了性能。这就是现实，以上是一个大概的介绍。

现在考虑一个问题，为什么应用程序一定要使用多核呢？这个实际上与过去几十年技术的发展有关，下面这张非常经典的图可以解释为什么。

![img](.assets/image%20(465).png)

x轴是时间，y轴是单位，Y轴具体意义取决于特定的曲线。这张图中的核心点是：

* 大概从2000年开始，CPU的时钟频率就不怎么增加了，不再变动了，<font color=green>绿色</font>；
* 这样的结果就是，CPU的单线程性能达到了一个极限并且没有增加了，<font color=blue>蓝色</font>；
* 另一方面，CPU中晶体管数量在持续增加，<font color=darkred>深红色</font>；
* 所以现在不能通过使用单核来让代码运行的更快，想要更快的话，只能使用CPU多核技术，所以从2000年，2001年开始，处理器上的核的数量开始增加，黑色。

所以现在如果应用程序想要提升性能，不能依赖单核，必须依赖于多核。这也意味着，如果应用程序与内核交互很紧密，那么操作系统也需要高效的在多核上运行。这也是我们对kernel运行在多核上感兴趣的原因。

所以为什么需要锁，前面已经提过了，因为需要确保正确性。多个readers跟多个writers对共享数据发起访问时，我们需要避免race conditions。race conditions是很令人讨厌的，我们先来看下什么是race condition，我们接下来会在XV6中创建一个race condition，然后看看它的表象是什么。

kalloc.c文件中的kfree函数会将释放的page保存在freelist中。

![img](.assets/image%20(541).png)

freelist是xv6中一个很简单的数据结构，它将所有可用的内存page保存于一个列表中。这样当kalloc函数需要一个内存page时，他可以从freelist中获取。从函数代码里面，可以看见有个锁kmem.lock。在加锁放锁的区间内，代码对于freelist进行更新操作。现在我们将锁的acquire与release操作注释掉，这样原来在上锁区间内的代码就不再受锁保护，并且不再是原子执行的。

![img](.assets/image%20(534).png)

然后重新编译make qemu

![img](.assets/image%20(497).png)

我们可以看到XV6已经运行起来，并且我们应该已经运行了一些对于kfree的调用，看起来一切运行都正常啊。

接下来运行一下usertest，究竟能不能成功呢？有人想猜一下吗？

> 学生回答：如果发生了race condition就会丢失一些内存page，如果没有发生就能成功。

是的，race condition不一定会发生，让我们来运行一下usertest，看看究竟会发生什么。我这里通过qemu模拟了3个core，这3个核是并行运行的。但是就如同刚刚那位同学指出的，race condition不一会发生，因为当每一个核在每一次调用kfree函数时，对于freelist的更新都还是原子操作，这跟有锁时候一样，这个时候没有问题。但是当两个core上的两个线程同时调用kfree函数时，并且交错执行更新freelist的代码，此时会出问题。

我们来看一下usertest运行的结果，可以看到已经有panic了。所以的确有一些race condition触发了panic。但是如前面的同学提到的，还有一些其他的race condition会导致丢失内存page，这种情况下，usertest运行并不会有问题。

![img](.assets/image%20(555).png)

以race condition可以有不同的表现形式，并且它可能发生，也可能不发生。但是在这里的usertests中，很明显发生了什么

