# wait系统调用

[toc]

通过Unix的exit和wait系统调用的说明，我们可以知道如果一个进程exit了，并且它的父进程调用了wait系统调用，父进程的wait会返回。wait函数的返回表明当前进程的一个子进程退出了。所以接下来我们看一下wait系统调用的实现。

![img](.assets/image%20(591).png)

它里面有一个很大的循环。当一个进程调用了wait系统调用，它就会扫描进程表单（proc[NPROC]）找出父进程是自己的且状态是ZOMBIE的进程。从上一节的内容我们知道，这些进程的exit流程几乎要执行完成了。之后是父进程调用freeproc函数，完成释放子进程资源的最后的步骤。

![img](.assets/image%20(493).png)

如果一个要exit的进程，自己执行这些步骤，将会非常奇怪。这里释放了trapframe，释放了page table，如果我们需要释放进程内核栈，那么也应该在这里释放。但是因为内核栈的guard page，我们没有必要再释放一次内核栈。不管怎样，当进程还在exit函数中运行时，任何这些资源在exit函数中释放都会很难受，所以这些资源都是由父进程释放的。

wait系统调用不仅仅时为了方便父进程知道子进程退出了。wait实际上是进程退出过程中十分重要的一环。在UNIX风格的系统中，对于每一个进程的退出，都必须有一个对应的wait系统调用与之对应。这就是为什么当一个进程退出了，它的子进程需要变成init进程的子进程。

init进程的工作就是在一个循环中不停调用wait，因为每个进程都需要对应一个wait，这样它的父进程才能调用freeproc函数，并清理进程的资源。

当父进程完成了清理进程的所有资源，子进程的状态（更确切的是内核线程的状态）被设置成UNUSED，此时，fork系统调用就可以使用这个proc[NPROC]进程表单的位置了。

>学生提问：在exit系统调用中，为什么需要在重新设置父进程之前，先获取当前进程的父进程？
>
>Robert教授：这里其实是防止一个进程和它的父进程同时退出。通常情况下，一个进程exit，它的父进程正在wait，一切正常。但是也可能一个进程和它的父进程同时exit。所以当子进程尝试唤醒父进程，并告诉它自己退出了时，父进程也在退出。这些代码我一年前还记得是干嘛的，现在已经记不太清了。它应该是处理这种父进程和子进程同时退出的情况。如果不是这种情况的话，一切都会非常直观，子进程会在后面通过wakeup函数唤醒父进程。
>
>学生提问：为什么我们在唤醒父进程之后才将进程的状态设置为ZOMBIE？难道我们不应该在之前就设置吗？
>
>Robert教授：在执行exit函数的线程，会先acquire（&p->lock）自己的锁，同时，因为父进程的wait系统调用中也需要获取子进程的锁，所以父进程并不能查看正在执行exit函数的进程的状态。这意味，从exit函数中获取自己的进程锁开始，直到进入sched函数切换到scheduler thread并释放exit进程的锁（注，因为调度器线程会释放进程的锁），这段时间内，父进程都没法查看exit进程的状态。所以这之间的代码顺序并不重要。<font color=red>大部分时候，如果没有持有锁，exit中任何代码顺序都不能工作。因为有了锁，代码的顺序就不再重要，因为父进程也看不到进程状态</font>。

这里我想强调的是，直到子进程执行完exit函数，它都没法释放自己的所有资源，因为它自己只要执行代码就没法子办这些事（注，人不可能自己把自己掐死）。相应的其他的进程，也就是父进程，释放了运行子进程代码所需要的资源。这样的设计可以让我们极大的精简exit的实现。