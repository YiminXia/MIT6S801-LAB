# 系统调用exit

[toc]

接下来，我想讨论一下xv6面临的一个与sleep&wakeup相关的挑战，也就是如何关闭一个进程。每个进程最终都需要退出exit，我们需要清除进程的状态，释放stack。在xv6中，一个进程如果退出的话，我们需要释放用户内存，释放page table，释放trapframe对象，将进程在进程表单中（procs[NPROC]中）标为REUSABLE，这些都是典型的清理步骤。当进程退出或者被杀掉时，有很多东西需要被释放。

这里会产生两个大问题；

* 首先我们不能直接单方面摧毁一个线程，因为，该线程可能正在另一个CPU上运行，并使用自己的stack。也可能该线程其对应的内核线程在kernel中持有了某个锁，也可能该线程其对应的内核线程正在更新一个负载的内核的数据结构。

  如果我们直接把线程杀掉了，我们可能在线程完成更新复杂的内核数据过程中就把线程杀掉了。我们不能让这里的任何一件事情发生。

* 另一个问题是，即使一个线程调用了exit系统调用，并且是自己决定要退出。它哪怕是退出这个过程，也是需要资源来执行退出过程的，比如它肯定需要stack，以及内核中进程表单（procs[NPROC]中的位置）中的位置。当它还在执行代码，它就不能释放正在使用的资源。所以我们需要一种方法让线程能释放最后几个对于运行退出代码来说的，比较关键的资源。

记住这两个问题。

XV6有两个函数与关闭线程进程相关。第一个是exit，第二个是kill。让我们先来看位于proc.c中的exit函数。

![img](.assets/image%20(439).png)

这就是exit系统调用的内容。从exit接口的整体来看，它需要释放process memory与page table，并关闭该进程打开的files，同时我们也知道其父进程会从wait系统调用中被唤醒，所以exit最终会导致父进程被唤醒。这些都是我们预期可以从exit代码中看到的内容。

从上面的代码中，首先exit函数关闭了所有自己打开的文件。这里可能会很复杂，因为关闭文件涉及到file system 中引用计数，然我们还没学到但是这里需要大量的工作。不管怎样，一个进程调用exit系统调用时，会关闭所有自己拥有的文件。

进程有一个记录是关于当前工作目前的（current working directory），这个记录会随着你执行cd命令而改变。在exit代码中，也需要将对这个目前的引用释放给文件系统。

如果一个进程要退出，但是它又有自己的子进程，接下来需要设置这些子进程的父进程为init进程。我们接下来会看到，<font color=red>每一个正在exit的进程，都有一个父进程中的对应的wait系统调用与之相应。实际上exit最后一些个步骤是由父进程中的wait系统调用完成的</font>。所以如果父进程退出了，那么子进程就不再有父进程，当它们要退出时就没有对应的父进程的wait。所以在exit函数中，会为即将exit进程的子进程重新指定父进程为init进程，也就是PID为1的进程。

![img](.assets/image%20(502).png)

之后，我们需要wakeup1函数唤醒当前进程的父进程，父进程可能正在等待当前进程退出。

接下来，进程的状态被设置为ZOMBIE。因为现在的进程还没有完全释放它的资源，所以这些资源不能被重用。所谓的进程重用是指，我们期望在最后，进程的所有状态都可以被一些其他无关的fork系统调用复用，但是目前我们还没有到那一步。

现在我们还没有结束，因为我们还没有释放进程资源。<font color=red>我们在还没有完全释放所有资源的时候，通过调用sched函数进入到调度器线程</font>。

所以“进程exit的故事”还没有结束，此时进程的状态还是ZOMBIE（僵尸），处于该状态的进程无法被执行，因为scheduler thread只会调度RUNNABLE状态的线程。此时该进程的资源也没有被完全释放，因为其状态也没有被设置成UNUSED。但是可以肯定的是进程不会再运行了，因为它的状态是ZOMBIE。所以调度器线程会决定运行其他的进程。