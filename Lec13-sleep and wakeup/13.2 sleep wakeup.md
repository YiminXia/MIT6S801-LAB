# sleep & wakeup接口

[toc]

接下来我们讲sleep&wakeup实现coordination

我们之前讲了很多关于locks的内容，locks的作用是让一个线程不用担心其他线程的具体实现。这句话怎么理解，我们给共享的数据加了锁，这样就不用担心其他thread是否在此时也在使用该共享数据。

但是当你在写一个线程的代码时，有些场景是需要等待一些特定的event，或者需要不同线程之间交互合作。

* 假设我们有个pipe，一个writer一个reader。reader从pipe中读数据，但是此时pipe中啥都没有，所以reader此时需要等待一个pipe not empty event。
* 类似的，reader需要读取disc，reader需要告诉disc controller我们要读取的特定的disc blocks。这或许需要花费较长时间，尤其当磁碟需要旋转时（通常是毫秒级别），磁盘才能完成读取。所以reader此时需要等待一个read disc completely event。
* 类似的，写代码时候调用的wait()系统调用。wait()函数的作用是，父进程调用wait（）函数来等待其任意一个子进程的exit。这可以理解成父进程在等待子进程的某个event。

![img](.assets/image%20(499).png)

上面这些例子都是一个process需要等待某个event的场景。特定event可能来自于I/O，也可能来自于另一个进程，并且它描述了某件事情已经发生。

coordination就是帮助我们解决这些问题的一种工具，coordination是一种非常基础的工具，就像locks一样，实现线程代码时候会经常用到。

我们怎么让进程或者线程等待一些特定的event呢？一种非常直观的方法是通过loop实现busy wait。假设我们想从一个Pipe读取数据，我们就写一个循环一直等待Pipe的buffer不为空。

![img](.assets/image%20(590).png)

上图的代码会让我们一直在循环，每次循环都试图read pipe直到有线程向pipe对应的buffer中写入了数据。之后循环才会结束，我们从pipe中读取相应的数据并返回。

实际也有这么写的代码，如果你知道你要等待的event极有可能在0.1微妙内发生，通过循环等待或许是最好的实现方法（网卡收包？），通常来说在操作硬件设备的代码中，会经常使用这种loop  busy wait方法，因为你知道硬件设备通常都会很快完成任务，loop busy wait是最优解。

另一方面，如果一个event不知道多久才会发生，比如可能几ms甚至10分钟才有进程向pipe中写入数据。那么我们就不想在这个loop中一直浪费CPU时间。这时我们想先出让CPU让它去干点别的，但是在我们关心的event发生了之后我们又能重新regain CPU。coordination就是这么个技术。

人们发明了很多不同的实现coordination技术的方法，但是与许多UNIX风格的操作系统一样，xv6的coordination的实现使用的sleep&wakeup这种方式。

介绍完背景了，接下来我们看一下XV6的代码。为了准备这节课，我重写了UART的驱动代码，XV6通过这里的驱动代码从console中读写字符。

![img](.assets/image%20(576).png)



首先是uartwrite函数，当Shell进程需要输出时候会调用write system call并最终调用uartwrite函数。uartwrite函数里面有个while循环，会一次一个字节的向UART芯片写入，这是一种典型的device driver 写法，你会在很多硬件驱动中看到这种写法。UART硬件一次只能接受一个字符的传输，但是通常来说会有很多字符需要写入UART硬件。你可以向UART硬件写入一个字符，并等待UART硬件说：好的我完成了传输上一个字符并且准备好了传输下一个字符，之后驱动程序才可以写入下一个字符。

这里硬件可能会非常慢，或许每秒只能传输1000个字符，所以我们在两个字符传输之间的等待间隔会很长，你要知道1ms对于CPU来说是很长的时间，可以让CPU执行百万条指令了。

所以我们不想通过循环来等待UART完成字符传输，我们想通过一个更好的方式来等待。如大多数操作系统一样，XV6也的确存在更好的等待方式。

UART芯片在完成一次字符的传输之后，会触发一个中断。所以UART驱动中除了uartwrite函数之后，还有个uartintr中断处理函数。当trap.c中的代码收到一次UART硬件中断，对应的中断处理函数就是uartintr：

![img](.assets/image%20(496).png)

uartintr函数会先读取UART芯片的memory mapped register，并检查其中表明传输字符完成的bit位，也就是LSR_TX_IDLE标志位，如果这个标志位为1，代码会将tx_done设置为1，并调用wakeup函数。wakeup函数的调用会使得uartwrite函数中的sleep函数恢复执行，然后uartwrite函数会尝试发生下一个字符。

所以这里的机制是：如果一个线程需要等待某些事件，比如说等待UART硬件愿意接收一个新的字符，线程调用sleep函数并等待一个特定的条件。当特定的条件满足时，代码会调用wakeup函数。这里的sleep函数和wakeup函数是成对出现的。sleep函数会做很多事情最后通过swtch函数出让yield CPU，之后我们会看sleep函数的具体实现。

这里有件事情需要注意一下，sleep函数与wakeup函数某种程度是联系在一起的，意思是当我们调用wakeup，我们是真的希望唤醒那些在等待某些特定event的线程。所以，sleep函数与wakeup函数都有一个叫做sleep channel的入参。调用wakeup时候输入的sleep channel就是调用sleep时传入的那个。不过sleep与wakeup函数只是接收这个sleep channel的64bit的地址，他俩都不关心这个入参的值代表什么。当我们调用sleep函数时，我们通过一个sleep channel表明我们等待的特定event，当调用wakeup函数时我们传入相同的sleep channel表示特定的event已经发生了，sleep的线程可以起来干活了。

>学生提问：进程会在写入每个字符时候都被唤醒一次吗？
>
>教授回答：在这个我出于演示目的而特别改过的UART驱动中，传输每个字符都会有一个中断，所以你是对的，对于buffer中的每个字符，我们都会等待UART可以接收下一个字符，之后写入一个字符，将tx_done设置为0，回到循环的最开始并再次调用sleep函数进行睡眠状态，直到tx_done为1。当UART传输完了这个字符，uartintr函数会将tx_done设置为1，并唤醒uartwrite所在的线程。所以对于每个字符都有调用一次sleep和wakeup，并占用一次循环。
>
>UART芯片实际上支持一次传输4或者16个字符，所以更有效率的写法是每次循环写16个字符给UART硬件，中断也是每16个字符产生一次。更高速的设备比如以太网卡，可能接收更多的字节才会触发一次终端。

以上就是接口的演示。Sleep&wakeup的一个优点是它们可以很灵活，sleep跟wakeup基本上不关心UART在干什么，它们不关心代码正在执行什么操作，你不用告诉sleep函数你在等待什么事件，你也不用告诉wakeup函数发生了什么事件，你只需要匹配好64bit的sleep channel就行。

对于sleep函数有一个有意思的地方，第二个入参必须传入一个lock，这背后是个很长的"故事"。但是先高屋建瓴的说一下原因，不太可能设计一个sleep函数并完全忽略线程要等待的event，所以实现一个通用的sleep函数，只是睡眠并等待一些特定的event是很难得，并且这也十分危险，这种危机叫做`lost wakeup`我们一会儿就能看到。

而几乎所有的Coordination机制都需要处理lost wakeup的问题。在sleep接口中，我们需要传入一个锁是一种稍微丑陋的实现，我在稍后会再介绍。