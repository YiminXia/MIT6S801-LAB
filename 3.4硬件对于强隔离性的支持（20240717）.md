# 硬件对于强隔离性的支持

[toc]

当你开发内核时，防御性是你必须掌握的一个思想，因为实际中，应用程序可能是恶意的，这意味着在操作系统与应用程序之间必须存在很强的隔离性。

通常来说，需要通过硬件来获取这种强隔离性，现在我们在这里简单介绍一下，后续课程会有更加详细的讲解。这里硬件的支持主要有2部分。

* 使用`user mode`与`kernel mode`在RISV-C也被称为`suppervisor mode`。
* 使用page table即virtual Memory。



所以，所有的处理器，如果需要运行能够支持多个应用程序的操作系统，那么肯定支持`user mode`与`kernel mode`+virtual Memory机制。我们这门课使用的RISC-V架构处理器就支持上述两条机制。

![img](.assets/image%20(74).png)

我们现在来讲一下user mode与kernel mode。我真正的意思是，处理器有两种工作模式，一种是user mode，另一种是kernel mode，当运行在kernel mode时，CPU可以执行某些特权指令（privileged instructions）。当处于user mode时，CPU只能执行非特权指令（unprivileged instructions），非特权指令就是大部分我们很熟悉的指令，将两个寄存器相加的ADD，相减的SUB。跳转指令JRC、BRANCH指令等等。这些都是普通权限指令，所有的应用程序都允许执行这些指令。

![img](.assets/image%20(22).png)

特权指令通常来说主要是那些可以直接与操纵硬件的指令，或者设置保护的指令。比如设置page table寄存器的指令，或者关闭时钟中断的指令。处理器上有各种各样的状态，操作系统会使用这些状态，但是只能通过特权指令来变更这些状态。

举个例子，当一个应用程序试图执行一条特权指令，因为不允许在user mode执行特权指令，处理器会拒绝执行这条指令，通常来说，这时会将权限控制从user mode切换到kernel mode，当操作系统拿到控制权限之后，或许会kill掉进程，因为应用程序的不当表现。

下图是RISC-V的privileged architecture文档，包含了所有的privileged instructions。在接下来的几周甚至几个月中，你会一直跟这些特权指令打交道。我们下节课会详细介绍其中一些指令。我们现在要记住的是：**应用程序不能执行特权指令，这些指令只能被kernel执行。**

>学生提问：如何kernel mode允许一些指令执行，user mode不允许一些指令执行，那么谁在检查当前的mode并执行这些指令，并且怎么知道当前是不是kernel mode，有什么标志位吗？
>
>教授答：是的，在处理器上有个bit位，为1时为user mode，为0时为kernel mode。当处理器在解析一条指令时，先检查这条指令的opcode如果opcode是特权指令并且bit位被设置为1，那么处理器会拒绝执行这条指令。就行处理器不会执行除以0指令一样。
>
>学生又问：所以，唯一的控制方式就是通过某种方式更行了那个bit位吗？
>
>教授答：是的，你认为是什么指令更新了那个bit位呢？是特权指令还是普通指令呢？很显然，是特权指令设置那个bit位，因为应用程序不应该能够设置那个bit位为kernel mode，否则的话应用程序就可以运行各种特权指令了。所以那个bit位是被保护的，明白了吗？

RISC-V架构还有第三种mode，即machine mode。在大多数时候，我们会忽略这个mode，所以我也不大会介绍这种mode，所以实际上我们有三级权限（machine/kernel/user mode），而不是二级权限(kernel/user mode)。

>学生提问：考虑到安全性，所有的用户代码都通过kernel，目的是这样做更安全，但是是否有这种可能让一个计算机的用户可以随意的操纵内核呢？
>
>教授答：并不会，至少小心设计的内核并不会发生这种事。或许一些程序会有额外的权限，操作系统也会认可这一点。但是这些额外的权限并不会给每一个用户。比如只有root用户有特殊权限，允许其完成安全性的相关操作。
>
>学生问： 那么BIOS呢，BIOS会在操作系统之前启动还是之后？
>
>教授答：BIOS是计算机自带的一段代码，BIOS先启动，之后BIOS启动操作系统启动，所以BIOS最好是正确的，非恶意的，可被信任的一段代码。
>
>学生问：之前提到，设置处理器那个bit位是一个特权指令，那么一个用户程序怎么才能让内核执行这条修改bit位的指令呢？因为现在切换到kernel mode的指令都是一条特权指令了，对于用户来说也没办法修改那个bit位。
>
>教授答：你说得对，这也是我们想要看到的结果。可以这么来看这个问题，首先这里不是完全按照你所说的方式工作的，在RISC-V中，如果你在用户空间（user space）尝试完成一条只有特殊权限的指令才能完成的操作的话（就是陷入内核的过程吧），用户程序会通过系统调用来切换kernel mode。当用户程序执行系统调用，会通过ECALL出发一个软中断（soft interrupt），软中断会查询操作系统预先设定的中断向量表，并执行中断向量表中包含的中断处理程序。中断处理程序在内核中，这样就完成了user mode到kernel mode的切换，并执行用户程序想要执行的只有特权指令才能完成的操作。

下面我们开始讨论第二点virtual Memory，基本上所有CPU都支持virtual Memory，下周三我们将会进行特别具体的讨论，现在你们只要知道，处理器上有个东西叫pagetable，其基本功能是将虚拟地址映射到物理地址。

其基本思想是为每个进程都提供一个属于自己的pagetable。这样的话，每个进程只允许访问它们自己pagetable中的物理内存，如果操作系统设置每个进程的pagetable都映射到互不重叠的物理内存的话，这样一个进程是不可能访问其他进程的物理内存的，因为其他进程的物理内存不在该进程的pagetable中。这种机制为我们提供了强内存隔离性（strong memory isolation）。

![img](.assets/image%20(27).png)

基本上，pagetable定义了一个进程的内存视图（view of memory），每一个用户进程都有一个自己的内存视图，且相互独立，这提供了强内存隔离性。

我们先画一个box，ls在这个box里面，在画一个echo的box。每个box代表一个进程的虚拟内存地址，范围从0到2^n。ls有内存地址0，同样echo也有内存地址0。操作系统会将这连个内存地址0映射到不同的物理地址上，这样ls就不会访问echo的内存，同理echo也无法访问ls的内存。

同样的，我们在下面画出kernel，kernel也有自己的内存地址空间至少XV6是这样的。并且与应用程序的完全相独立。



