# xv6中线程切换的代码走读

[toc]

接下来我们看下xv6的代码，首先我们先看下proc.h文件中的proc的结构体，从proc的结构体中我们会发现很多我们刚才介绍的内容，

![img](.assets/image%20(826).png)

* 首先是保存用户线程寄存器的trapframe字段，该字段是个指针。
* 其次是用于保存内核线程寄存器的context字段，该字段是个结构体。
* 还有保存了当前内核线程栈的kstack字段，这是内核线程在内核中执行时，保存函数调用的位置。内核线程执行需要栈，这个就是栈底地址就是kstack的值，栈顶为`p->trapframe->kernel_sp = p->kstack + PGSIZE`。
* 还有stateful字段，它记录了进程的状态RUNNING或者RUNNABLE或者SLEEPING。
* 还有lock字段保护了很多数据，目前来说至少保护了对于state字段的更新，举个例子来说，两个scheduler线程都在检索proc[NPROC]数组，就不会同时选择同一个RUNNABLE内核线程让它运行在两个CPU上。

我接下来会运行一个简单的演示程序spin，在这个程序中我们会从一个进程切换到另一个。

![img](.assets/image%20(762).png)

这个spin的程序（program）会创建两个进程，两个进程都会一直执行（因为下面有个for循环）。

代码首先通过fork函数创建了一个子进程，然后两个进程都会一如一个for循环，该for循环每隔一段时间会输出一个字符，但是不会很频繁的输出打印，从代码上来看也没有主动出让CPU的代码（指的是没有主动调用sleep系统调用），所以我们这里有了两个运算密集型进程，并且因为我们接下来启动的XV6只有一个CPU核，它们都运行在同一个CPU上。为了让这两个进程都能运行，有必要让两个进程之间能相互切换。

接下来让我们运行spin程序

![img](.assets/image%20(680).png)

你可以看到一直有字符在输出，一个进程输出"/"，另一个进程输出“\”。从输出看，虽然只有一个CPU，但是每隔一会，xv6就在两个进程之间切换。“/"输出一会之后，定时器中断将CPU切换到另一个进程然后又输出一会“\”。所以在这里我们可以看到定时器中断在起作用。

接下来，我在trap.c的devintr函数中的207行设置一个断点，这一行会识别出当前是在响应定时器中断。

![img](.assets/image%20(448)%20(1)%20(1)%20(1)%20(1).png)

![img](.assets/image%20(724).png)

之后再gdb中continue。立刻会停在中断的位置，因为定时器中断是很频繁的，现在我们可以确认我们在usertrap函数中，并且usertrap通过devintr函数来处理定时器中断，这是通过where命令看出的内核线程调用栈得出的。看下图：

![img](.assets/image%20(643).png)

接下来我们输入finish来从devintr函数中返回到usertrap函数，因为在devintr函数关于定时器中断没有什么特殊的处理，虽然我们刚刚从devintr函数中返回，但是我们期望运行到下面的yield函数。所以我们期望devintr函数返回2。

![img](.assets/image%20(801).png)

可以从gdb中看到devintr的确返回的是2。

![img](.assets/image%20(727).png)

在yield函数中，当前进程会出让CPU并让另一个进程运行，这个我们稍后会看，我们现在看下当定时器中断发生的时候，用户空间进程正在执行什么内容。我再gdb中输入print p来打印p变量，量p指向当前进程的proc结构体。

>学生提问：怎么区分不同进程的内核线程？
>
>robert教授：每个进程都有一个对应的独立的内核线程，实际上有两件事情可以区分不同进程的内核线程：
>
>* 一个是，每个进程对应的内核线程都有自己的内核栈，由proc结构体中的kstack字段所指向。
>* 另一个是，在usertrap函数中，或者内核代码中，都可以通过myproc函数来获取当前CPU正在运行的进程指针p，内核线程可以通过这个函数知道自己属于哪个用户进程对应的内核线程。myproc函数是通过tp寄存器来获取当前CPU的ID值，然后通过这个ID值来找到cpus[NCPU]数组中对应的cpu结构，该结构体中有当前在这个CPU上运行的proc结构它的指针。找到对应的proc结构体。这就是不同的内核线程区分自己的方法。

我首先会打印p->name来获取进程的名称，

![img](.assets/image%20(813).png)

当前的进程ID是3，进程切换之后，我们预期进程ID会不一样。

我们还可以通过打印变量p的trapframe字段获取表示用户空间状态的32个寄存器，这些都是我们在Lec06中学过的内容。这里面最有意思的可能是trapframe中保存的用户程序计数器。

![img](.assets/image%20(696).png)

我们看下spin.asm文件来确定下对应地址0x62的指令是啥

![img](.assets/image%20(758).png)

可以看到定时器中断触发时，用户进程正在执行死循环的加1，这符合我们的预期。既不是什么系统调用，也不是什么sleep操作，就是普通的加法，因为定时器中断，直接就给陷入内核了。

（注，以下问答来自课程结束部分，因为相关就移过来了）

> 学生提问：看起来所有的CPU核要能完成线程切换都需要有一个定时器中断，那如果硬件定时器出现故障了怎么办？
>
> Robert教授：是的，总是需要有一个定时器中断。用户进程的pre-emptive scheduling能工作的原因是，用户进程运行时，中断总是打开的。XV6会确保返回到用户空间时，中断是打开的。这意味着当代码在用户空间执行时，定时器中断总是能发生。在内核中会更加复杂点，因为内核中偶尔会关闭中断，比如当获取锁的时候，中断会被关闭，只有当锁被释放之后中断才会重新打开，所以如果内核中有一些bug导致内核关闭中断之后再也没有打开中断，同时内核中的代码永远也不会释放CPU，那么定时器中断不会发生。但是因为XV6是我们写的，所以它总是会重新打开中断。XV6中的代码如果关闭了中断，它要么过会会重新打开中断，然后内核中定时器中断可以发生并且我们可以从这个内核线程切换走，要么代码会返回到用户空间。我们相信XV6中不会有关闭中断然后还死循环的代码。
>
> 同一个学生提问：我的问题是，定时器中断是来自于某个硬件，如果硬件出现故障了呢？
>
> Robert教授：那你的电脑坏了，你要买个新电脑了。这个问题是可能发生的，因为电脑中有上亿的晶体管，有的时候电脑会有问题，但是这超出了内核的管理范围了。所以我们假设计算机可以正常工作。
>
> 有的时候软件会尝试弥补硬件的错误，比如通过网络传输packet，总是会带上checksum，这样如果某个网络设备故障导致某个bit反转了，可以通过checksum发现这个问题。但是对于计算机内部的问题，人们倾向于不用软件来尝试弥补硬件的错误。

> 学生提问：当一个线程结束执行了，比如说在用户空间通过exit系统调用结束线程，同时也会关闭进程的内核线程。那么线程结束之后和下一个定时器中断之间这段时间，CPU仍然会被这个线程占有吗？还是说我们在结束线程的时候会启动一个新的线程？
>
> Robert教授：exit系统调用会出让CPU。尽管我们这节课主要是基于定时器中断来讨论，但是实际上XV6切换线程的绝大部分场景都不是因为定时器中断，比如说一些系统调用在等待一些事件并决定让出CPU。exit系统调用会做各种操作然后调用yield函数来出让CPU，这里的出让并不依赖定时器中断。