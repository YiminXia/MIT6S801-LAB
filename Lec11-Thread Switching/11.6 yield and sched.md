# xv6的线程切换，yield/sched函数

回到devintr函数返回到usertrap函数中的位置。在gdb里面输入几次step走到yield函数的调用。yield函数是整个线程切换的第一步，下面是yield函数的内容

![img](.assets/image%20(663).png)

yield函数的做了几件事情：

* 它首先acquire了进程的lock，实际上在lock释放之前，进程的状态会变得不一致，例如yield函数将进程的状态修改为RUNNABLE，这表明该进程没有在CPU运行，但是此时这个进程还是在CPU上正在执行的对吧。所以这里加锁的目的之一就是：即使我们将进程的状态修改为RUNNABLE，其他CPU的线程调度器线程（scheduler线程）也不可能看到进程的状态为RUNNABLE并尝试运行它。否则的话，进程就会在两个CPU上运行了，而一个进程只有一个栈，这意味着两个CPU在同一个内核栈上运行代码（注，因为XV6中一个用户进程只有一个用户线程）。
* 接下来yield函数中将进程的状态改为RUNNABLE。这里的意思是，当前进程要出让CPU，并切换到scheduler thread。当前进程的状态是RUNNABLE意味着它还可以再次被运行，因为毕竟现在是一个定时器中断打断了当前正在运行的进程。

之后yield函数中调用了位于proc.c文件中的sched函数。我们进入到sched函数中：

![img](.assets/image%20(516)%20(2)%20(2)%20(2)%20(1).png)

可以看出，sched函数基本没有干任何事情，只是做了一些合理性检查，如果发现了异常情况就panic。为什么会有这么多检查？因为这里的XV6代码已经有很多年的历史了，这些代码经历过各种各样的bug，相应的这里就有各种各样的合理性检查和panic来避免可能的bug。我将跳过所有的检查，直接走到位于底部的swtch函数。

