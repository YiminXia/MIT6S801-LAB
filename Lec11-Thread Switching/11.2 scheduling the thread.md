# 线程调度

[toc]

实现内核中线程系统存在以下挑战：

* 第一个是如何实现线程之间的切换。这涉及到停止一个线程的运行并启动另一个线程，这个过程通常被称为线程调度（thread scheduling）。你将会看到xv6的调度器，事实上xv6为每个CPU都创建了一个线程调度器（scheduler）。
* 第二个挑战是，当你想要实现从一个线程切换到另一个线程，你需要保存并恢复线程的状态。我们需要决定线程的哪些信息是需要保存？在哪里保存？
* 最后一个挑战是，如何处理计算密集型线程（compute bound thread）。对于线程的切换，我们已经有了很直观的认识，就是线程资源保存自己的状态，然后让其他线程运行。但是如果一些线程本身的计算是需要花费数小时的计算任务呢？这种线程并不能自愿的出让CPU给其他线程运行。所以这里需要能从长时间运行的“计算密集型线程”撤回对于CPU的控制的手段，让它们让出CPU，稍后再执行。

![img](.assets/image%20(748).png)

接下来，我们先将最后一个挑战，如何处理“计算密集型线程”的处理。处理这种挑战的方案我们之前就接触过，就是利用timer Interrupt即定时器中断。

每个CPU都有一个硬件设备，它会定时的产生中断，xv6或者其他的操作系统会在内核中会收到这种定时器中断。所以即使我们正在用户空间计算π的前100万位，计时器中断还是会每10ms产生一次，将程序的控制权（指令执行序列）从用户空间切换到内核空间（从用户程序代码，切换到内核处理定时器中断代码）。哪怕这些用户空间的进程并不配合工作（注，也就是用户空间进程一直占用CPU），内核也可以从用户空间进程获取CPU控制权。

定时器中断处理函数位于kernel中，这个timer Interrupt kernel handler会yield（这里用yield这个词表示出让）出CPU给线程调度器，让后跟他说你可以让其他线程运行了。这种yield出让其实就是一种线程调度，它会保存当前线程的状态，并在稍后恢复。

![img](.assets/image%20(686).png)

在之前的课程中我们已经了解了中断的处理流程。这里的基本思想是，定时器中断导致代码执行控制权给到kernel，kernel再自愿yield出让CPU给线程调度器（thread scheduler）。这种处理流程被称为pre-emptive scheduling（抢占式调度）。

这里pre-emptive表示，即使用户代码本身没有主动的自愿的yield出让CPU，定时器中断仍然会将CPU的控制权拿走，并yield出让给线程调度器。与之相反的是voluntary scheduling （aka 自愿型调度）。

![img](.assets/image%20(751).png)

有趣的是，在xv6和其他的操作系统中，线程调度是这么实现的：定时器中断会强制的将CPU控制权从用户进程给到kernel内核，这里用的是pre-emptive scheduling，之后内核会代表用户进程（注，实际是内核中用户进程对应的内核线程会代表用户yield出让CPU），这里用的是voluntary scheduling。

在执行线程切换的时候，操作系统需要区分几类线程：

* 当前在CPU上运行的线程
* 那些想要运行的线程，但是还没有在任何CPU上执行的线程，一旦某个CPU有空了随时可以运行的那种线程。
* 那些根本就不想运行的线程，比如这些线程正在等待IO或者别的什么

上面对线程的划分是依据线程的状态来划分的，但是实际上线程的完整的状态比这个要复杂的多（注，线程的完整状态包含了程序计数器PC，寄存器REGS，stack等等）。下面是我们将会看到的一些线程的“状态”：

* RUNNING，线程此时正在某个CPU上运行。
* RUNNABLE，线程此时还没有运行，但是已经准备就绪了，一旦有空闲的CPU我们就能运行。
* SLEEPING，线程此时可能正在等待IO事件，它只会在IO事件发生之后运行

![img](.assets/image%20(784).png)

今天这节课，我们主要关注RUNNING和RUNABLE这两类线程。

前面介绍的定时器中断干的事情，或者pre-emptive scheduling干的事情，实际上是将一个RUNNING状态的线程切换成了一个RUNNABLE线程。通过yield出让CPU，pre-emptive scheduling将当前这个RUNNING状态的线程编程RUNNABLE线程，因为当定时器中断触发时，这个线程还在好好的运行着。

对于RUNNING状态的线程，此时它的PC，REGS都在硬件CPU上；

但是RUNNABLE状态的线程，因为还并没有跟某个硬件CPU产生关联，我们需要找地方将它的信息保存起来，保存的是当它处于RUNNING状态时的这些CPU contents，注意不是RAM，只是一些寄存器（PC，REGS等），将这些CPU content从CPU的硬件里面读出来，保存在内存中的某个位置。

因此，当线程调度器决定要运行一个RUNNABLE状态的线程时，这里面通常涉及到很多步骤，但是其中一个就是将这些保存的CPU content即PC与REGS重新拷贝回CPU上。