# xv6线程切换（二）

[toc]

实际的线程切换流程会复杂很多。



假设我们现在有一个进程P1正在运行，P2进程此时状态是RUNNABLE但是当前并没有在运行。我们假设实际上我们环境是多核的有2个CPUS，这意味在硬件层面上，我们有CPU0，跟CPU1。

![img](.assets/image%20(692).png)

我们要描述的故事是，如何从一个正在运行的用户空间的进程P1切换到另一个RUNNABLE但是当前还没有运行的用户空间的进程P2。

1、首先与我们之前介绍的一样，一个定时器中断，强迫的将CPU控制前从用户空间进程转移到内核空间，trampoline中的代码将用户寄存器都保存P1进程对应的trapframe对象中；

2、之后在内核中运行usertrap函数，来实际执行相应的中断处理程序。这时，CPU正在进程P1的内核线程和内核栈上，执行内核中普通的C代码；

3、假设进程P1对应的内核线程决定它想yield出让CPU，它会做很多工作，这个我们稍后会看，但是最后它会调用swtch函数（注，switch是C语言关键字，因此这个函数命名为swtch来避免冲突），这是整个线程切换的核心函数之一；

4、swtch函数会保存用户进程P1对应内核线程的寄存器至context对象。所以目前为止有两类寄存器：用户寄存器存在trapframe中，内核线程的寄存器存在context中。

![img](.assets/image%20(799).png)

但是，实际上swtch函数并不是直接从一个内核线程切换到另一个内核线程。xv6中，一个CPU上运行的内核线程可以直接切换到的是这个CPU对应的调度器线程(scheduler函数)。所以如果我们运行在CPU0，swtch函数会恢复之前为CPU0的专有调度器线程（scheduler0）的保存的寄存器与stack pointer，之后我们将在scheduler0的context环境下开始执行线程调度器函数（scheduler函数），scheduler函数也会做一些清理工作，比如将P1进程的状态设置为RUNNABLE等。

![img](.assets/image%20(759).png)

之后scheduler函数会遍历proc[64]数组，找到一个RUNNABLE状态的线程P2，甚至如果都不是RUNNABLE状态的话还会选择P1进程，scheduler函数会再次执行swtch函数，完成下面的步骤：

1、先保存scheduler函数的寄存器信息到context对象。

2、找到进程P2之前保存的自己对应的内核线程的context，恢复其中的寄存器。

3、因为P2进程之前也是调用swtch函数切换到scheduler函数，就跟P1进程刚才做的事情一样，所以此时P2的内核线程会回到系统调用或者中断处理函数中继续执行。（注，因为P2进程之前调用swtch函数必然在系统调用或者中断处理程序中）。

4、当P2进程对应的内核线程执行完了，会通过trapframe中保存的用户寄存器回到用户空间的P2进程中去。最后P2进程就恢复运行了。

![img](.assets/image%20(765).png)

每一个CPU都有一个完全不同的scheduler线程调度器。线程调度器某种程度上也可以成为一种内核线程，它也有自己的context上下文对象。任何运行在CPU1上的进程，当它决定出让自己的CPU时，它都会先切换到CPU1对应的线程调度器scheduler1上，然后通过scheduler1切换到下一个进程。

![img](.assets/image%20(747).png)

>学生提问：context保存在哪里？
>
>robert教授答：每个内核线程都有一个context对象，因为任何一个线程都只能在它的context上下文中才能正常的执行。但是内核线程实际上有两类。每一个用户进程有一个对应的内核线程，它的context对象保存在用户进程对应的proc结构体中（p->context）。
>
>每一个CPU对应的线程调度器scheduler也是一种内核线程，但是它却没有对应的进程的proc结构体，实际上scheduler的context保存在CPU结构体中（cpu->context）。在内核代码中有个CPUs结构体的数组，每个结构体中有一个context的字段。



>学生提问：为什么不能将context对象保存在进程对应的trapframe中？
>
>robert教授回答：context可以保存在trapframe中，因为每个进程都只有一组与内核线程对应的寄存器，我们可以将这些寄存器保存在任何一个与进程一一对应的数据结构中。对于每个进程来说，有一个proc结构体，有一个trapframe结构体，所以我们可以将context保存于trapframe中。但是或许出于简化代码或者让代码更清晰的目的，trapframe还是只包含进入和离开内核时的数据。而context结构体中包含的是在内核线程和调度器线程之间切换时，需要保存和恢复的数据。



>学生提问：出让CPU是由用户发起的还是由内核发起的？
>
>Robert教授：对于xv6来说，并不会直接让用户线程出让CPU或者完成线程切换，都是由内核在合适的时间点做决定并完成的。有时候你可能会感觉到某些系统调用会导致yield出让CPU，如果你个用户进程调用了read pipe这种系统调用时，而此时pipe中啥都没有，这时你可以预测read会被阻塞，而内核在等待数据的过程中会运行其他的进程。
>
>内核会在两种情况下yield出让CPU。一种是timer Interrupt来了，内核会让当前的内核线程出让CPU，因为我们想要在定时器中断而产生的一段段时间间隔上交织执行所有能够运行的进程。
>
>另一种场景是用户进程调用了系统调用并产生了IO waiting，例如等待你敲入下一个按键，在你还没有按下按键时，等待I/O的机制会触发出让CPU。

>学生提问：用户进程调用sleep函数是不是会调用某个系统调用，然后将用户进程的信息保存在trapframe，然后触发进程切换，这时就不是定时器中断决定，而是用户进程自己决定了吧？
>
>rebort教授：如果用户进程调用了 read的系统调用，会陷入内核代码，此时read系统调用的内核代码实现会waiting，waiting获取一次disk硬盘的读取，或者waiting一个pipe中出现数据，总之read系统调用在内核中的代码会调用sleep函数，而sleep函数中会调用swtch函数。swtch函数会保存内核线程的寄存器到进程的context中（p->context），然后切换到对应CPU的调度器线程（scheduler内核线程），再让其他的内核线程运行。这样在当前线程等待磁盘读取结束时，其他内核线程还能运行。所以，这里的流程除了没有定时器中断，其他都一样，只是这里是因为一个系统调用需要等待I/O（注，感觉答非所问）

>学生提问：每一个CPU的调度器线程有自己的栈吗？
>
>robert教授：是的，每一个调度器线程都有自己独立的栈。实际上调度器线程（scheduler内核线程）的所有内容，包括stack与context，都跟用户进程不大一样，它们在系统boot的时候都设置好了。如果你看xv6中的start.s（注：是entry.S和start.c）文件，你就可以看到为每个CPU核设置好调度器线程。

<font color=red>这里有个问题，schedualer线程stack占用的memory是怎么划分的呢</font>

这里有个专业术语需要解释一下。当人们说context switching，他们通常说的是从一个线程切换到另一个线程，在切换的过程中需要保存旧线程的寄存器，然后恢复新线程的之前被保存的寄存器。这些寄存器都是保存在context对象中。在有些时候，context switching也指从一个用户进程切换到另一个用户进程的完整过程。

偶尔你也会看到context switching指的是从用户空间到内核空间的切换。但对于我们本节课来说，context switching更多指的是一个kernel thread与一个scheduler的内核线程之间的切换。

这里有一些信息我希望你们可以记住：

* 每个CPU在任何一个给定的时间点只能运行一个线程，它要么运行的是一个user thread（xv6中的user process中只有一个user thread暂时不支持类似Linux中的多thread in one user process）要么运行的是一个kernel thread（xv6中的kernel thread有两类，一类是user process对应的kernel thread，一类是schedular thread）,所以在任意一个时间点，CPU不能同时做几件事，都是只能干一件事。正在这种切换现象导致了多个thread可以在同一个CPU上交错运行。
* 另一方面，一个thread要么运行在一个CPU上，要么它的状态被保存在context中，就在一边呆着根本没有运行，线程永远无法运行在多个CPU上同时运行。
* 另一个关于xv6的有趣的事情是，上图中保存了内核线程寄存器的context中的信息，都是由swtch函数产生的，所以这些context中保存的寄存器的信息都是kernel thread在执行swtch函数时候寄存器的信息，所以对于那些刚恢复运行的内核线程来说，第一件事情就是从之前的swtch函数中返回注，有点抽象，后面有代码分析）。

>学生提问：我们这里一直在说线程，但是从我看来XV6的实现中，一个进程就只有一个线程，有没有可能一个进程有多个线程？
>
>robert教授：我们这里的用词确实有点令人混淆。在xv6中，一个进程要么在用户空间执行指令，要么在内核空间执行指令，要么它的状态被保存在内核线程对应的context中，或者user process对应的trapframe中，并且此时没有执行任何指令。
>
>这里该怎么称呼它呢？你可以根据自己的喜好来称呼它，对于我来说，一个用户空间线程，一个内核空间线程，并且存在限制使得一个process要么是运行在用户空间的线程，要么为了执行系统调用或者相应中断而运行在内核空间的线程，但是永远也不会两者同时运行。
>
>（PS：<font color=red>响应中断运行的内核线程，此时p指针指向proc结构体还是该用户线程对应的内核线程，中断函数使用的内核栈跟该用户进程调用系统调用时候使用的内核栈是同一个，只是该中断或者中断处理函数做的事情跟该用户进程可能没有任何业务上的关系罢了</font>）
>
>



