# 操作系统结构

[toc]

​        这是操作系统内部组织结构，我想用这个方框来代表计算机，计算机大约附带很多硬件资源，我把它们放在下面，它们可能是CPU，RAM，硬盘，可能还有网卡。

​      在顶部，你想运行各种各样不同的程序，比如一个文本编辑器，这里我使用VI代表文本编辑器，比如你想要运行一个C编译器，用CC表示，还有我们今天要大量讨论的shell，一个命令行接口界面，所以现在我们有很多不同的程序在正在运行。我们把所有这些程序运行的世界，通常称作`Userspace`。

​		区别于用户空间的程序，这里有一个单独的程序，一个特殊的程序，她一直在运行，我们叫她`kernel`。`kernel`是计算机资源的守护者。`kernel`在打开计算机时第一个启动，她维护数据来管理用户空间中运行的每一个进程，`Kernel`同时还维护了大量的数据结构来帮助她管理各种各样的硬件资源，以供用户空间的程序使用。`kernel`同时也有很多内置服务，比如文件系统，它实现了文件名，文件内容，目录之类的东西，并知道如何将这些东西存储在硬盘上，所以你的应用程序访问文件，而实际则是文件系统访问硬盘。

​		这门课我们主要关注发生在`kernel`中的事情，以及应用程序与`kernel`之间的接口，以及`kernel`内部的软件的结构。所以，我们会关心`kernel`中的服务，其中一个就是上面提到的`FS`，另一个则是`progress manage`，用户空间运行的每一个程序都叫`progress`（进程）它们都拥有自己的内存，还有共享CPU时间。`PM`作为一个内核服务，管理内存的分配，不同的进程需要不同的内存，`kernel`还会复用内存，划分内存，并为所有的进程提供内存。

​		`FS`实际上由三个或更多的逻辑分区组成的，但是现在，我们仅从管理文件内容的方面去考虑它。`FS`负责找到文件具体在磁盘中的位置。`FS`还维护了一个独立的命名空间，其中每个文件都有一个文件名，命名空间中有一个层级目录，每个目录中包含了很多文件，这些都归`FS`管理。

​		通常会有某种安全考虑，这里我们称其为`Access Control`。当一个应用进程希望读取或者使用某些资源时，内核中的`Access control`机制会决定是否运行其这样做。这些对于一些分时共享的计算机，比如Athena，事前会变得比较复杂，因为每个应用进程可能属于不同的用户，并且拥有不同的`access control`规则，这些规则决定是否运行访问相应的资源。

​		在一个真正成熟的操作系统中，会有很多很多服务，比如`IPC`(inter process communication)允许进程之间相互通信，比如很多软件需要网络通信，所以需要支持TCP/IP协议栈，比如支持声卡，比如支持数百种不同的磁盘。所以一个成熟的系统中，内核会包含很多内容，数百万行的代码。

​		我们还对应用程序如何与内核交互，以及这些交互的接口感兴趣。这里通常称为内核的API，它决定了应用程序如何访问kernel。通常来说，这里是通过所谓的系统调用`system calls`来完成。系统调用看起来与函数调用很像，但实际上执行指令已经跳入内核并执行内核中实现的系统调用函数。

​		

​		在应用程序的源码中系统调用的看起来是什么样子的呢？比如，应用程序想打开一个文件，它调用`open`系统调用，并将文件名作为入参传给`open`系统调用，第一个入参是文件名`out`，第二个入参是1表示应用程序想写这个文件。

​		所以这看起来像一个函数调用，它打开了系统调用，实际上已经跳入内核中的指定代码，内核可以检索这些入参，然后执行一些内核代码，比如访问磁盘，然后返回一个值，返回的值就是文件描述符`fd`。应用程序之后可以使用这个`fd`作为handle，来表示相应的打开的文件。

​		如果你想写入一个文件，相应的系统调用是`write`，你必须传入一个由`open`返回的文件描述符`fd`作为入参，你还需要传递一个指向字符缓冲区的指针，这在C语言中很方便做到，一个带双引号的字符串就行，其中`\n`表示换行。第三个入参表示你要写入的字符个数。

​		第二个参数`"hello\n"`这相当于将地址传递到内存中，相当于你告诉kernel，请将这个地址开始的6个字节写入这个`fd`对应的文件中。

​		

​		下面说`fork`系统调用，其作用是创建了一个与`caller`一模一样的进程，并返回新锦成的`PID`。

​		这些系统调用看起来就跟普通的函数调用一样，但是系统调用是特别的，因为她们会跳入kernel。

​	



