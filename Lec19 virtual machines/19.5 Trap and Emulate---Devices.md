# Trap and Emulate --- Devices

[toc]

接下来我们来看Trap and Emulate的最后一个部分，也就是虚机的外部设备。外部设备是指，一个普通的操作系统期望能有一个disk来存储它的文件系统，或许期望有一个网卡，对于xv6这种操作系统来说，它可能期望有一个UART芯片，如此可以与console来交互，或者期望有一个声卡，一个显卡，一个键盘，一个鼠标等等这些东西。所以对于我们的虚拟机方案，我们需要让Guest认为这些Guest需要的外部设备是“真实”存在的。

这里通常会有三种策略。

第一种，模拟一些需要用到的并且使用非常广泛的设备，比如disk。也就是说，Guest并不需要拥有一个真实的物理disk设备，VMM使得与Guest交互的disk看起来跟真的一样。这里的实现方式是，Guest操作系统尝试与devices通过memory mapped control register进行交互，这也是xv6与UART的交互方式，xv6之所以能与一些控制寄存器交互，是因为这些硬件已经将控制寄存器映射到某些xv6内核知道的内存地址上了。

VMM中不会映射这些寄存器内存地址对应的page，相应的会将这些page设置成无效的，所以当Guest操作系统想跟UART硬件进行交互时，会生成一个Trap并陷入VMM中。VMM相应的处理函数会发现，此时Guest想发送一个character给UART，或者Guest想从disk中读取数据。VMM中会对磁盘或者串口设备有一些模拟，通过这些模拟，VMM知道如何响应Guest的指令，之后再恢复Guest的执行。这就是QEMU如何模拟UART的过程，xv6就是这么被糊弄的。

在之前的介绍中，根本就没有UART硬件设备存在，QEMU模拟了一个UART来哄xv6高兴，这是一种常见的实现方式。但是这种方式的性能很差，因为Guest操作系统与devices硬件的每一次交互都会产生一个Trap。但是对于一些低速场景，这种工作方式工作的很好。如果你的目标就是能启动操作系统，并使得操作系统完全不知道自己运行在虚拟机上，你只能使用这种策略。

![img](.assets/image%20(489).png)

第二种，操作系统在最底层是知道自己运行在虚拟机之上的。所以第二种策略是提供虚拟设备，而不是模拟一个“真实”设备。在VMM中构建高效的设备接口，使得Guest中的设备驱动与VMM内支持的设备进行高效的交互。Guest中没有memory mapped control registers了，但是相应的内存中会有一个命令队列，Guest操作系统将读写设备的命令写到队列里。

xv6中也使用了这种方式的设备驱动，如果你看了xv6代码中的virtio_disk.c文件，你会看到一个xv6的设别驱动尝试与QEMU实现的一个虚拟磁盘设备（disk virtual device）进行交互。所以在这个驱动里面，你会发现只是使用了很少的memory mapped control registers，也就是产生了很少的trap，相应的它在内存中格式化了一个命令队列。之后QEMU会从内存中读取这些个命令，但并不将这些命令应用到真正的磁盘上，而是应用到一个类似xv6中的fs.image文件上去。这种方式相比与第一种策略直接模拟硬件设备，这种方式性能要更高，因为你可以在VMM中设计设备接口，并不需要太多的trap。

![img](.assets/image%20(550).png)

第三种策略是对于真实设备的pass-through，这种策略的典型例子就是网卡（注：SR-IOV技术）。现代网卡具备硬件支持，支持网卡可以直接跟VMM运行的多种Guest操作系统进行交互。你可以配置你的网卡，使得它像多个独立的子网卡，每个Guest操作系统都拥有一个子网卡。经过VMM的配置，Guest操作系统可以直接与分配给它的那块子网卡交互，交互效率相当的高。在这种方式中，Guest操作系统中的驱动可以知道它们正在与这种特别的网卡进行交互。

![img](.assets/image%20(552).png)

以上就是实现外部设备的各种策略。我认为在实现一个VMM时，主要的困难就在于构建外部设备和设备驱动，并使得它们能正确的与Guest操作系统配合工作。这里或许是实现VMM的主要工作，尤其是当你使用第一种策略时。

>学生提问：我并没有太理解策略一emulation和策略二virtual device的区别。
>
>Robert教授：它们是相似的。如果你启动了一个完全不知道自己运行在虚拟机上的操作系统，这个操作系统里面会有很多d磁盘驱动（disk driver），这些驱动都是为真实的物理设备准备的（Linux中根据磁盘厂商不同，启动不同的驱动，所以会有一大堆disk driver在内核中）。如果你想在虚拟机中启动这个操作系统，你需要选择其中一个硬件设备，然后非常准确的模拟它。这种方式本身没有问题，但是大多数硬件接口并没有考虑trap and emulate VMM下的性能（PS，产生trap之后陷入VMM，VMM再模拟硬件设备，然后返回给Guest），所以当Guest中这些设备驱动需要你频繁的读写它的control registers，VMM需要为每一次的写control registers的命令，VMM需要先获取控制权，因为VMM需要模拟真实的硬件。这意味着每一次写控制寄存器都会触发一次trap走到VMM，并消耗数百个CPU cycles。所以策略一非常的慢且低效。
>
>策略二并没有卑微的模拟真实的设备，某些设计人员提出了一种设备驱动，这种设备驱动并不是为任何真是的硬件所准备的，单纯为了对接由VMM实现的虚拟设备。这种驱动的设计并不需要很多trap，并且这种驱动与对应的虚拟设备是解耦的，并不需要立即交互。
>
>第一种策略，你可以启动任何操作系统，使用第二种策略的话，如果你想要使用VMM中虚拟设备，你得确定Guest操作系统支持VMM中的虚拟设备。实际中，策略二是一种标准，并且很多虚拟机的实现方案都能提供。虽然我们并没有在除了QEMU以外的其他场景测试过，XV6中的virtio_disk.c稍作修改或许也可以在其他虚拟机方案上运行。
>
>学生提问：所以对于每一种主板，取决于不同的磁盘，编译XV6都需要不同的磁盘驱动，是吗？
>
>Robert教授：是的。我认为或许你可以买到支持virtio_disk驱动的真实硬件，但是大部分的磁盘硬件还不支持这个驱动，这时你需要为真实的硬件实现一种新的驱动。





