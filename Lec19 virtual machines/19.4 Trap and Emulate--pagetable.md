# Trap and emulate --- pagetable

[toc]

有关Trap and Emulate的实现还有两个重要的部分，一个是pagetable，另一个是外部设备。

pagetable包含了两部分内容：

Guest操作系统修改SATP寄存器（注，SATP寄存器是物理内存中包含了Page Table的地址，详见4.3），当然这会触发一个Trap并陷入VMM，但是我们不希望VMM只是简单的让Guest修改真实的SATP寄存器，因为这样的话Guest就可以访问任意的内存地址，而不仅仅是VMM分配给Guest的内存地址，所以我们不能让Guest操作系统简单的设置SATP寄存器。

但是我们的确需要对SATP寄存器做点什么，因为我们需要让Guest操作系统觉得pagetable确实被更新了。当Guest上运行的软件执行了load或者store指令时，或者CPU读取程序的指令来执行时，我们需要知道数据或者指令的正确内存位置。也就是Guest操作系统认为其PTE指向的内存位置。

所以当Guest设置SATP寄存器时，真实过程是，我们不能直接使用Guest操作系统的pagetable，VMM会生成一个新的pagetable来模拟Guest操作系统想要的pagetable。

所以现在的pagetable在翻译过程中稍微有点不一样，首先是Guest Kernel 的pagetable，将Guest的虚拟地址（注，下图中gva)映射到Guest的物理内存地址(注，下图中的gpa)。Guest的物理地址是VMM分配的，假如是32GB。VMM会告诉Guest这段物理内存地址从0开始到32GB结束。但是在实际硬件中，这部分内存并不是连续的，所以我们不能直接使用Guest的物理地址，因为它们并不对应真实的物理内存。

VMM会为每个虚拟机维护一个映射，这个映射将Guest的物理内存映射到真正的物理内存上去（注，Guest physical address映射到host physical address），这是映射就跟pagetable差不多，每一个Guest认为存在的physical page都有一个entry与之对应，根据这个entry可以找到真实的physical page。

![img](.assets/image%20(432).png)

当Guest向SATP寄存器中写了一个新的pagetable时，在VMM对应的trap handler的处理中，VMM会创建一个shadow page table。VMM将这个shadow pagetable的地址写入真实的SATP寄存器中，这个shadow pagetable相当于上图中Guest pageTBL（gva->gpa）与VMM MAP(gpa->hpa)的结合体，shadow pagetable可以直接将gpa映射到hpa。shadow pagetable是怎么构建的呢？

* 从Guest  pagetable中取出每一条记录，找出对应的gpa
* 通过VMM映射将gpa翻译成hpa
* 将gva与hpa存放于shadow pagetable中。

在创建完成之后，VMM会将shadow pagetable设置到真实的SATP寄存器中，之后再返回到Guest Kernel（注，这样的效果是，Guest里面看到的Page Table就是一个正常的Page Table，而Guest通过SATP寄存器指向的Page Table，将虚拟内存地址翻译得到的又是真实的物理内存地址）。

![img](.assets/image%20(577).png)

所以Guest Kernel认为自己使用的是一个正常的pagetable，但是实际上硬件使用的是shadow pagetable。这个机制可以阻止Guest从VMM分配给它的memory中逃逸。shadow pagetable中只包含VMM分配给Guest的真实的物理内存地址。Guest不能通过pagetable写入任何VMM未分配给Guest的内存地址。这是VMM实现隔离的一个关键部分。

>学生提问：如果Guest操作系统想要为一个进程创建一个新的Page Table，会发生什么呢？
>
>Robert教授：Guest做法会完全按照Linux或者xv6的传统做法来做。首先都是Guest内核先格式化（注，format）一个pagetable entry来构造一个pagetable。之后执行指令将pagetable的地址写入SATP寄存器，这就是Guest操作系统的行为。但是Guest Kernel无法直接配置SATP寄存器，因为这是个privileged指令，这会产生一个trap并陷入VMM，此时VMM的trap  handler会发现Guest Kernel正在尝试修改STAP寄存器，之后VMM会创建一个新的Shadow Page Table。VMM会查看Guest尝试要设置的Page Table的每一条记录，通过gpa->hpa的映射关系，将gva和hpa的对应关系翻译出来。如果Guest尝试使用一个不被允许的物理地址，VMM会生成一个真实的Page Fault。之后VMM会将Shadow Page Table设置到真实的SATP寄存器中，并返回到Guest中。

shadow page table是实现VMM时一个比较麻烦的地方。除了设置SATP寄存器，Guest操作系统还有另一种方式可以与pagetable进行交互。xv6有时会直接修改属于自己的page table entry。或者读取PTE中的dirty bit。如果你读了RISC-V的文档，你会发现如果软件更改了PTE，RISC-V并不会做任何事情。如果你修改了PTE，RISC-V并不承诺可以立即观察到对于PTE的修改，在修改那一瞬间，你完全是不知道PTE被修改了（注，这里主要对比的是privileged指令，因为如果在用户空间执行了privileged指令，会立刻触发trap，而这里修改PTE不会有任何的额外的动作）。

相应的，文档是这么说的，如果你修改了PTE并希望MMU可以看到这个改动，你必须执行sfence.vma指令，该指令会强制硬件注意到你对pagetable的修改。如果你要自己写一个VMM，你这个运行在RISC-V上的VMM会完全忽略Guest对PTE的修改，但是你知道Guest在修改完PTE之后将会执行sfence.vma指令（注，因为根据RISC-V手册不执行就没法用），并且这是个privileged指令，因为它也是s开头的，所以这条指令会通过trap走到VMM，VMM就知道sfence.vma指令执行了，VMM会重新扫描Guest当前的pagetable，找到更新了的PTE。如果修改是合法的话，VMM会将这个修改体现在shadow pagetable中，并执行真实的sfence.vma指令来让真实的硬件注意到shadow pagetable的改动，最后会返回到Guest Kernel中。

>学生提问：所以MMU只使用了一个Page Table，也就是Shadow Page Table，对吧？这里并没有使用EPT（Extended Page Table），对吧？
>
>Robert教授：这里还没有EPT。
>
>学生提问：所以Guest认为它自己有一个Page Table，也就是gva->gpa，但是这里并没有做任何的翻译工作。VMM通过两个映射关系构建了属于自己的Page Table。
>
>Robert教授：是的。这里澄清一下，EPT是一种非常不一样的虚拟机实现方式，并且需要硬件的支持。我们这里假设除了对privileged指令触发trap以外，不需要使用任何特殊的硬件支持来构建一个虚拟机。
>
>学生提问：这里会弄乱direct mapping吗？
>
>Robert教授：这里不会有direct map，Guest Kernel会认为自己有一个direct mapping，但这只是在虚拟世界里的一个direct mapping（xv6内核中的一一映射，但还是gva->gpa），在真实机器上这不是direct mapping，。但是这没有关系，因为我们这里欺骗了Guest使得看起来像是direct mapping。
>
>学生提问：我们刚刚说过性能的损耗，如果我们使用VMM，对于这里的trap机制看起来也会有大量的性能损耗。
>
>Robert教授：是的，如果你的操作系统执行了大量的privileged指令，这会导致你的操作系统会花费大量的时间处理trap，这会对性能有损耗。我们一会会讲到现代硬件对虚拟机的支持，我们今天的论文就是讲现代硬件对于虚拟机的支持，Intel与AMD在硬件上在硬件上支持更有效的trap，或者对于虚拟机方案，会有更少的trap。
>
>性能很重要，但是我们这节课到现在介绍的虚拟机方案，人们也使用了很多年，这个方案能工作而且很成功，尽管它确实很慢，但是没有慢到让人们放弃的地步，事实上大家很喜欢这个方案。

