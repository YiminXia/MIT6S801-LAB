# Why Virtual Machine

[toc]

今天讨论的换题是virtual machines。今天的内容包含三个部分。

* 第一部分是Trap and Emulate，这部分会介绍如何在RISC-V的QUME上构建属于自己的Virtual Machine Monitor（注，有些场合也称作Hypervisor）。
* 第二部分会描述最近在硬件上对于虚拟化的支持。
* 最后是讨论一下今天的[论文](https://pdos.csail.mit.edu/6.828/2020/readings/belay-dune.pdf)，它使用了第二部分中硬件上的支持。

首先什么是虚拟机？你可以认为这是对于计算机的一种模拟，这种模拟足够运行一个操作系统。QEMU可以认为是虚拟机的一个例子（注，QEMU应该是属于VMM/Hypervisor）。

在架构的最底层，位于硬件之上存在一个Virtual Machine Monitor（VMM），它取代了标准的操作系统内核。VMM的工作是模拟多个计算机，模拟的多个计算机用来运行Guest操作系统。VMM再往上一层，如果对比一个操作系统的架构应该是user space，但是现在叫做Guest space。

所以我们画的架构图里面，上面是Guest space，下面是Host space(注，也就是上面运行一个或多个Guest操作系统，下面运行VMM)。

![img](.assets/image%20(580).png)

在Guest space，会有一个或者多个Guest操作系统内核，或许其中一个是Linux Kernel。此时的Linux Kernel会觉得自己是个普通的内核，并在自己之上还运行一堆用户进程，例如VI，C Compiler。我们或许还有另一个Guest运行了Windows操作系统，同时也包含了Windows用户进程。

所以，在 Host space运行的是VMM，在Guest space中运行了若干个普通的操作系统。更进一步，Guest space又分为Guest Supervisor mode（即Guest操作系统的Kernel运行时的mode），跟Guest user mode。

![img](.assets/image%20(413).png)

VMM的主要目的是什么，是提供一种计算机的模拟，这种模拟可以启动普通的Linux，普通windows，并运行在虚拟机内，并且不用担心任何奇怪的事情发生。所以，VMM必须要能够完全按照实际硬件的行为来模拟Guest Supervisor Mode和Guest User Mode，尽管实际上不可能完全一样，我们之后会讨论VMM对于这两种模式的模拟。

那么为什么人们想要使用虚拟机呢？

* 实际生活中，有很多原因使得人们会在一个计算机上运行多个相互独立的操作系统。在一个大公司里面，你需要大量的服务，比如firewall，DNS等等，但是这些服务都不太会使用太多的资源，所以为他们单独购买物理计算机有点浪费，但是将这些低强度服务以虚拟机的形式运行在一个物理机上，则可以节约很多时间与金钱。

* 另一方面，虚拟机在cloud compute（云计算）中的使用也非常广泛。云厂商，例如AWS，不想直接出租物理服务器给用户，因为这很难管理。云厂商想向用户出租的是可以随意确定不同规格的服务器。或许有两个用户在一台物理服务器上，但是他们并没有使用太多的服务器资源，这样AWS可以继续向同一个物理服务器上加入第三个或者第四个用户。这样就可以不使用额外的资金而获得额外的收入。这里借助的技术是：<font color=red>将操作系统内核从之前的Kernel space上移到user space，新加了一层VMM以提供灵活性。（PS，也就是虚拟机的内核是运行在宿主机的user space，虚拟机的内核通过新增加的一层VMM来对接底层硬件）</font>

* 还有一些其他原因会使得人们使用虚拟机。第一个是内核开发，这就是为什么我们在课程中一直使用QEMU，能够在虚拟环境而不是一个真实的计算机运行XV6，使得这门课程对于你们和我们来说都要方便的多。同时对于debug也更容易，因为相比在物理计算机上运行XV6，在QEMU提供的虚拟机环境中运行可以更容易的提供gdb的访问权限。

* 最后一个，人们喜欢使用虚拟机的原因是，通过新增的VMM提供的抽象可以实现更多的功能：
  * 例如，你可以为整个操作系统和其中的用户进程做一个快照，并在磁盘中保存下来。稍后再恢复快照，并将操作系统和其中的用户进程恢复成做快照时的状态。这可以增加运行的可靠性，或者用来debug，或者用来拷贝虚拟机的镜像并运行多次。
  * 除此之外，还可以将一个Guest操作系统迁移到另一个计算机上。如果你在一个物理计算机上运行了一个Guest操作系统，现在需要关闭并替换该物理计算机，你可以在不干扰虚拟机运行的前提下，将它迁移到另一个物理计算机，这样你就可以安全的关闭第一个物理计算机。

以上就是人们喜欢使用虚拟机的原因。虚拟机实际上应用的非常非常广泛，并且它也有着很长的历史。虚拟机最早出现在1960年代，经过了一段时间的开发才变得非常流行且易用。

对于我们这门课程来说，我们之所以要学习虚拟机是因为VMM提供了对于操作系统的一种不同视角。在操作系统的架构中，内核之上提供的封装单元（PS，视频中说的是container，但是container还有容器的意思，所以这里翻译成封装单元）是我们属性的进程，内核管理的是多个用户进程。而在VMM的架构中，VMM之上提供的封装单元某种程度上说虚拟的计算机。

所以VMM的架构使得我们可以从另外一个角度重新审视我们之前学过的内容，例如内存分配，线程调度等等，这或许可以给我们一些新的思路并带回到传统的操作系统内核中。所以，在虚拟机场景下，大部分的开发设计研究工作，从传统的内核移到了VMM。某种程度上来说，传统操作系统内核的内容下移了一层到了VMM。

今天课程的第一部分我们将会学习如何实现我们自己的虚拟机。这里假设我们要模拟的是RISC-V，并运行针对RISC-V设计的操作系统，比如xv6。我们的目的是让运行在Guest中的代码完全不能区分自己是运行在一个虚拟机里面，还是运行在一个物理机中，因为我们希望能在虚拟机中运行任何操作系统，甚至是你没有听过的操作系统，这意味着对于任何操作系统使用硬件的方式，虚拟机都必须提供完全相同的硬件模拟。这样任何在真实硬件上能工作的代码，也同样能在虚拟机中工作。

我们除了不希望Guest发现自己运行在虚拟机中，我们也不希望Guest可以从虚拟机中逃逸。很多时候人们使用虚拟机是因为虚拟机为不被信任的软件，甚至为不被信任的操作系统提供了严格的隔离。假设你是Amazon，并且你出售云服务，通常是你的客户提供了运行在虚拟机内的操作系统和应用程序，所以有可能你的客户运行的不是普通的Linux而是一个特殊的修改过的Linux，并且会试图突破虚拟机的限制来访问其他用户的虚拟机或者访问Amazon用来实现虚拟机隔离的VMM。所以Guest不能从虚拟机中逃逸还挺重要的。

Guest可以通过VMM使用内存，但是不能使用不属于自己的内存。类似的，Guest也不应该在没有权限的情况下，访问存储设备或者物理网卡。所以这里我们会想要非常严格的隔离。虚拟机在很多方面比普通的Linux进程提供了更加严格的隔离。<font color=red>Linux进程经常可以相互交互，它们可以杀掉别的进程，它们可以读写相同的文件，或者通过pipe进行通信。但是在一个普通的虚拟机中，所有这些都不被允许。运行在同一个物理计算机上的不同虚拟机，彼此之间被VMM完全隔离。</font>所以出于安全性考虑人们更喜欢使用虚拟机，这是一种可以运行未被信任软件的方式，不必担心bug与恶意攻击。

VMM的目的是提供一种对于物理计算机的完全的模拟。但是实际中出于性能考虑，这个目标很难达到，你将会看到运行在Guest中的Linux与VMM之间会相互交互，所以实际环境中Linux是可以发现自己是否运行在VMM之上的。出于效率的考虑，在VMM允许的前提下，<font color=red>Linux某些时候知道自己正在与VMM交互，以获得对于设备的高速访问权限。但这是一种被仔细控制的例外，实现虚拟机的大致策略还是完全准确的模拟物理服务器。</font>

-----

这里讲的模型是，宿主机没有运行Linux操作系统，而是直接运行一种VMM。