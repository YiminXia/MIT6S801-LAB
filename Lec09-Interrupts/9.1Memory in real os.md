# 9.1 真实操作系统内存使用情况

[toc]

今天的课程的内容是中断(interrupts)。但在具体介绍中断(interrupts)之前，我想先回顾一下上周一些内容。上周的课程主要讲的是内存，我们收到了很多内存相关的问题。我想先讨论一下真实操作系统是如何使用内存。

这是一台Athena计算机（注，MIT内部共享使用的计算机）的top指令输出。你先看下这个Memory行。

![img](.assets/image%20(364).png)

首先是计算机中总共有多少内存（33048332），如果你再往后看的话，如果你仔细看的话，你会发现大部分都已经被使用了（4214604 + 26988148），对吧？但是大部分内存实际上并没有被应用程序所占用，而是被buff/cache用掉了。这在一个操作系统中还是很常见的，你不会真的想让你的物理内存空闲着什么都不做，我们想让物理内存被用起来，所以这里大块的内存被用作buff/cache。可以看到还有一小块内存是空闲的（1845580），但是并不多。

以上是一个非常常见的场景，大部分操作系统运行时几乎没有任何空闲的内存。这意味着，如果一个应用程序或者内核需要使用内存，那么我们需要丢弃一些已有的内容。现在的空闲内存（free）或许足够几个page用，但是在某个时间点如果需要大量的内存的话，要么从应用程序，要么从buffer/cache中，撤回已经使用的一部分内存。所以，当内核在分配内存的时候，通常都不是个低成本的操作，因为并不总是有足够的可用的内存。



另外，我这里将top的输出按照RES进行了排序（the amount of resident memory）。如果你查看输出的每一行，VIRT表示虚拟内存地址空间的大小，RES是实际使用的内存数量。从这里可以看出，实际使用的内存数量远小于地址空间的大小。所以，上节课我们讨论的基于virtual Memory与page fault提供的非常酷的功能，在这里都有使用。比如Demand paging.

有关这台机器的其它信息还有：

- 即使它有103个用户登录进来了，它的负载还是很低
- 它有许多许多的进程
- 这台机器已经运行了249天，我们的XV6系统或许运行不了这么久

这里想传达的信息：大部分内存都被使用了，并且RES内存远小于VIRT内存。











