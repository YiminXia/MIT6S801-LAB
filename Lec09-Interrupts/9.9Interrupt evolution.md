# interrupt的演进 evolution

[toc]

最后我想介绍一下Interrupt在最近几十年的演进。当Unix刚被开发出来的时候，Interrupt处理还是很快的。这使得硬件可以很简单，当外设有数据需要处理时，硬件可以中断CPU的执行，并让CPU处理硬件的数据。

而现在，中断相对于处理器来说变慢了。从前面的介绍可以看出来这一点，需要很多步骤才能真正的处理中断数据。如果一个设备在高速的产生中断，处理器将会很难跟上。所以如果查看现在的设备，可以发现，现在的设备相比之前做了更多的工作。所以在产生中断之前，设备上会执行大量的操作，这样可以减轻CPU的处理负担。所以现在硬件变得更加复杂。

如果你有一个高性能的设备，例如你有一张千兆以太网网卡，这个网卡收到了大量的小包，网卡每秒可以到1.5Mpps，每个小包64Byte大小。这意味着每一个微妙（micro sec），CPU都需要处理一个中断，这就超过了CPU的处理能力。那么当网卡收到大量包，并且处理器不能处理这么多中断的时候该怎么办呢？

这里的解决方法就是使用polling。除了依赖Interrupt，CPU可以一直读取外设的控制寄存器，来检查是否有数据。对于UART来说，可以一直读取RHR寄存器，来检查是否有数据。现在CPU可以不停的轮训设备，直到设备有了数据。

这种方法浪费CPU cycles，当我们使用CPU在不停检查寄存器内容时，我们并没有使用CPU来运行任何程序。在我们之前的例子中，如果没有数据，kernel会让shell进程sleep，这样kernel会被调度去运行其他进程。

所以对于一个慢设备，我们肯定不想一直轮询，们想要在没有数据的时候切换出来运行一些其他程序。但是如果是一个快设备，那么Interrupt的overhead（费用）也会很高，那么polling该快设备时候，会经常能拿到数据，这样可以节省进出中断的代价。

所以对于一个高性能网卡，如果有大量的网络packet要传入，那么应该使用polling。对于一些精心设计的驱动，它们会在polling和Interrupt之间动态切换（注，也就是网卡的NAPI机制）

![img](.assets/image%20(398).png)