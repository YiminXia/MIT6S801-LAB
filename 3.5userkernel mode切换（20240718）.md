# user/kernel mode切换

[toc]

我们可以认为user/kernel mode是分隔用户空间和内核空间的边界，用户空间运行的程序运行在user mode，内核空间的程序运行在kernel mode。操作系统位于内核空间。

![img](.assets/image%20(8).png)

基于我们已经介绍的内容，这个图有点太严格了。我们几乎将所有的东西都放在box里面，但是没有说明一个box如何将控制权转移到另一个box。但是这种控制权转移是必须的，比如当你的ls进程调用read或write system call；shell进程调用fork或exec。

所以必须要有一种方式，使得用户应用程序能够将控制权以一种协同工作的方式转移到内核，这样内核才能提供相应的服务。如下图所示：

![img](.assets/image%20(61).png)

所以，需要有一种方式能够让应用程序可以将控制权转移给内核或者叫陷入内核（Entering Kernel）。

在RISC-V中有一个专门的指令负责这个，叫ECALL指令。ECALL指令接收一个数字入参，当一个用户应用程序想将控制权转移到kernel，它只需调用ECALL指令并传入一个数字参数2,3,4,5。这个数字代表了应用程序想要调用的system call。

![img](.assets/image%20(78).png)

ECALL实际上做的是跳入到内核中的一个特定的位置，由内核控制的问题。在xv6中有一个单独的系统调用进入点（single system call entry Point），每次应用程序调用ECALL都会从这个特定的点进程kernel。举个例子：当你的shell进程或prime程序（util lab中的习题）调用fork，并不是直接调用操作系统内核中相应的函数。实际上，它调用的是ECALL，并将fork对应的数字sys_fork作为参数传给ECALL。之后通过ECALL跳转到内核。

左边是用户空间，右边是内核空间。在内核空间有一个syscall函数位于syscall.c源文件中，每一个从应用程序发起的系统调用都会调用到这个syscall函数，syscall函数会检查ECALL的入参数字，这个入参数字由寄存器传入，打个比方由a0这个寄存器传入，通过这个参数内核可以知道需要调用的是内核中的fork函数继续处理（3.9会有相应的代码跟踪介绍）。

![img](.assets/image%20(79).png)

这里想说的就是，用户空间与内核空间的界限是一个硬性的界限，用户不能直接调用fork，用户的应用程序执行系统调用的唯一方法就是通过ECALL指令。

假设我们现在要执行另一个系统调用write，流程是类似的。write的系统调用不能直接调用内核中的write代码，而是由封装好的系统调用函数执行ECALL指令。所以write函数实际上调用的是ECALL指令，指令的参数是代表了write系统调用的数字。之后控制权转移到syscall函数，syscall会实际调用write系统调用。

![img](.assets/image%20(77).png)

>学生提问：操作系统在什么时候检查是否允许执行fork或者write？现在看起来应用程序只需要执行ECALL再加上系统调用对应的数字就能完成调用，但是内核在什么时候决定这个应用程序是否有权限执行特定的系统调用？
>
>教授答：原则上讲，在内核侧，即fork调用真正运行的的位置，它可以实现任何想要的安全检查。例如检查系统调用的参数，并决定应用程序是否允许执行fork系统调用。在UNIX中，任何应用程序都可以调用fork。我们以write为例吧，write的实现需要检查传递给write的地址（需要写入数据的指针）属于用户应用程序，这样内核才不会被欺骗从别的不属于应用程序的位置写入数据。
>
>学生提问：当应用程序表现的恶意或者就是在一个死循环中，内核如何从用户程序中夺回控制权？
>
>教授答：几周之后我们会进行更详细的讨论，内核会通过硬件设置一个定时器，定时器到期之后会将控制权从用户空间转移到内核空间。之后内核就有了控制权，并可以将CPU重新调度到另一个进程中。
>
>学生提问：这其实是个顶层设计问题，是什么驱动了操作系统的设计人员使用编程语言C？
>
>教授答：C语言提供了很多对硬件的控制能力，比如，当你需要对一个定时器芯片（timer chip）进行编程时，C语言会很容易做到这些，因为你可以得到更多对于硬件资源的底层控制能力。所以，如果你要做大量的底层开发，C会是一个非常方便的编程语言，尤其是需要与硬件交互的时候。当然，不是说你不能用其他的编程语言，但是这是C成功的一个历史原因。
>
>学生问：为什么C比C++更流行，仅仅是因为历史原因吗？有没有其他的原因导致大部分操作系统没有采用C++？
>
>教授答：我认为有一些操作系统使用C++写的，这是完全可能得。但是大部分你知道的操作系统并不是用C++写的。Linux使用C而不是C++，我认识部分原因是因为linus本人不喜欢C++。







