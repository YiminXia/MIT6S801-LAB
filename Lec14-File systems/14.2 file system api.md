# File system API与 File System structure

[toc]

为了理解文件系统必须提供什么能力，让我们再看一下一些与文件系统相关的基础系统调用。从这些系统调用接口，我们将可以推断出有关文件系统实现的一些细节，这些系统调用我们在之前的课程已经看过了。首先让我们来看一个简单的场景，假设我们创建了文件“x/y”，或者说在目录x中创建了文件y，同时我们需要提供一些标志位flag，现在我们还不太关系标志位所以我会忽略它，直接画个横杠。

![img](.assets/image%20(605).png)

上面的系统调用会创建文件，并返回文件描述符给调用者。调用者也就是用户应用程序可以对文件描述符调用write，有关write我们在之前已经看过很多次了，这里我们向文件写入“abc”，3个字符。

![img](.assets/image%20(616).png)

从这两个调用已经可以看出一些信息了：

* 首先出现在接口中的路径名（pathname）是可读的名字("x/y")，而不是一串数字，它是由用户选择的字符串。
* write系统调用并没有使用offset作为参数，所以写入到文件的哪个位置即offset是隐式包含在文件系统中。因为如果你第二次调用write系统调用，新写入的数据会从第4个字符位置开始。

除此之外，还有一些我们之前没有看过的有趣的系统调用。xv6与UNIX风格的文件系统都支持通过系统调用创建link，同一个file会有多个名字，你可以通过调用link系统调用，为之前创建的文件“x/y”创建另一个名字“x/z”。

![img](.assets/image%20(450).png)

所以file System内部肯定存在某种机制可以跟踪指向同一个文件的多个文件名。

我们还可以在文件打开时，删除或者更新文件的命名空间。例如，用户可以通过unlink系统调用来删除特定的文件名。如果此时相应的文件描述符还是打开的，那我们的进程还是可以向文件写数据，并且这也能正常工作。

![img](.assets/image%20(621).png)

所以，在文件系统内部，文件描述符必然与某个对象关联，而这个对象不依赖文件名。这样即使文件名变了，文件描述符仍然能够指向或者引用相同的文件对象。所以，实际上在操作系统内部需要对于文件有其内部的表现形式，并且这种表现形式与文件名无关。

![img](.assets/image%20(407).png)

除此之外，我还想提一点。文件系统的目的是实现上面描述的API，这些都是典型的文件系统API。但是这并不是唯一构建一个存储系统的方式，如果只是在磁盘上存储数据，你可以想出完全不同的API。举个例子，数据库也可以持久化的存储数据，但是数据库就提供了一个与文件系统不一样的API。

所以记住这一点很重要：<font color=red>还是存在其他的方式能组织存储系统。我们本节课关注的是file system，文件系统通常由操作系统提供，而数据库如果没有直接访问磁盘的权限的话，通常是在文件系统之上实现的（注，早期的数据库通常直接基于磁盘构建自己的文件系统，因为早期操作系统自带的文件系统在性能上较差，且写入不是同步的，进而导致数据库的ACID不能保证。不过现代操作系统自带的文件系统已经足够好，所以现代的数据库大部分构建在操作系统自带的文件系统之上）</font>

>学生提问：link增加了对于文件的一个引用，unlink减少了一个引用？
>
>Frans教授：是的。我们稍后会介绍更多相关的内容。
>
>学生提问：能介绍一下soft link和hard link吗？
>
>Frans教授：我今天不会讨论这些内容，但是你们将会在下一个File System lab中实现soft link，所以xv6本身实现了hard link，需要你们来实现soft link。
>
>学生提问：link是对inode做操作，而不是对文件描述符做操作，对吧？
>
>Frans教授：是的，link是对inode做操作，我们接下来介绍这部分内容。

接下来我们看下File System structure。文件系统酒精维护了什么样的结构体，来实现上面介绍各种API呢？

首先，最重要的部分是inode。这是代表一个file的对象，并且它不依赖于文件名。实际上，inode是通过自身的编号来进行区分的，这里的编号就是个整数。所以文件系统内部通过一个数字，而不是通过文件路径名引用inode。同时，基于之前的讨论，inode必须有一个link count来跟踪指向这个inode的文件名的数量。一个文件（inode）只能在link count为0的时候才能被删除。

实际的过程可能更加复杂，实际中还有一个openfd count，也就是当前文件对应的打开了的文件描述符计数。只有一个文件在上述两个计数都为0的时候才能顺利删除。

![img](.assets/image%20(510).png)

同时基于之前的讨论，我们也知道write与read都没有针对文件的offset参数，所以文件描述符fd必然自己悄悄维护了对于这个文件的offset。

![img](.assets/image%20(532).png)

所以文件系统的核心数据就是inode和file descriptor。后者文件描述符负责与进程process进行交互。

尽管文件系统的API看起来差不多，但是其内部实现可能非常不一样。但是很多文件系统都有类似的结构。因为文件系统还挺复杂的，<font color=red>所以最好按照分层的方式进行理解</font>。可以这样看：

* 最底层是磁盘，也就是实际存储数据的设备，也是实际提供持久性的设备（persistence and durability）。
* 在这之上是buffer cache或者叫block cache，这些cache可以避免我们频繁的读写磁盘。这里我们将磁盘中的数据保存在了内存中。
* 为了提供持久性（persistence）,会有一层叫做logging layer，很多文件系统都有某种形式的logging，我们下节课会讨论这部分内容，所以今天我就跳过它的介绍。
* 在logging层之前，xv6有inode cache，这主要是为了同步（synchronization），我们稍后会介绍。inode通常小于一个disk block，所以多个inode会打包在一个disk block中。为了这些inodes提供同步功能，xv6维护了inode cache。
* 在网上就是inode本身了，实现了read跟write等诸多操作。
* 最上层，就是文件名，文件描述符操作。

![img](.assets/image%20(412).png)

不同的文件系统，其组织方式和每一层都可能略有不同，有的时候分层也没有那么严格，即使在xv6中分层也不是很严格，但是从概念上按照上图那么分层去理解是很不错的。实际上所有的文件系统都有组件对应这里不同的分层，例如buffer cache，logging，inode和路径名。

