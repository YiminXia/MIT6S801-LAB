# 宏内核 VS 微内核（Monolithic kernel vs Micro Kernel）

[toc]

现在我们有了一种方法，使用系统调用或者ECALL指令将控制权转移到内核。之后内核负责实现具体的功能与检查入参以确保不会被一些坏的参数所欺骗。所以内核有时候被称为可被信任的计算空间（Trusted computing base）也叫TCB。

基本上说，TCB意味着kernel必须是正确的没有bug的。如果kernel有个bug，那么攻击者可能利用这个bug，并将其转变成漏洞，这个漏洞可能允许供给制打破isolation，然后接管kernel。所以尽可能的让kernel没有bug是十分重要的。

![img](.assets/image%20(80).png)

另一方面，kernel必须将用户应用程序，或者应用程序的进程当做是恶意的。正如我之前所提到的，kernel的设计者在设计与开发kernel时，需要有安全思想。完全没有bug是很难实现的目标，因为当一个操作系统十分庞大的话，很多事情就变得不那么直截了当了。你知道的，几乎每一个操作系统的用户是十分的广泛，所以时不时就会出一个安全漏洞，你修复了它，但是过一段时间就又会出来一个。我们之后会介绍为什么很难让所有部分都正确工作，但是你要知道，kernel必须做一些tricky的事情。kernel必须操纵硬件，必须很小心的检查，所以kernel很容易出现一些小的疏漏，进而出现小bug。

![img](.assets/image%20(81).png)

一个有趣的问题时，什么代码应该运行在kernel mode，敏感的代码肯定是运行在kernel mode，因为这是Trusted Computing Base。

对于上面问题的一个回答是，我们有user/kernel mode这个边界，上面是user mode有用户应用程在运行，下面是kernel mode也有程序在运行，一种选择是将所有的操作系统代码都运行在kernel mode。大部分的UNIX操作系统的实现都是运行在kernel mode。XV6中，所有的操作系统服务都运行在kernel mode。这种被称为宏内核设计（Monolithic Kernel Design）。

![img](.assets/image%20(89).png)

这里有几件事情需要注意：

* 这种设计，一旦出现bug的话，这种设计就不是很好。任何一个出现在宏内核的bug都有可能转变成一个漏洞，这不好。因为我们在kernel中运行了一个巨大的操作系统，所以出现bug的概率更大。通过查询统计数据平均每3000行代码就会出现几个bug。所以如果有很多代码运行在kernel mode，那么出现严重bug的几率就会上升。所以从安全性的角度看，宏内核的缺点是kernel中代码太多了。
* 不过好处是，这个操作系统几乎包含了所有部分，文件系统部分，虚拟内存部分，进程管理部分，等等。这些都是操作系统的实现了特定功能的子模块。这些子模块都集成在同一个程序之中，它们紧密的集成在一起，这样的集成提供很好的性能。比如Linux，他就有很好的性能。

![img](.assets/image%20(86).png)

上面是对于内核的一种设计方式，宏内核设计。

另一种kernel的设计的关注点，就是减少运行在kernel mode中的代码，它被称为微内核设计（Micro kernelDesign），在这种模式下，你的目的就是尽可能减少在kernel mode下运行的代码。这种设计下，kernel只有非常少的几个模块，比如有IPC（进程间通信）模块或message passing模块，有对VM十分有限的支持的模块（可能只支持了tablepage），以及一些支持CPU复用的代码。

微内核的目标是将大部分操作系统运行在kernel之外，如下图所示，很多之前运行在kernel mode的部分现在作为用户应用程序在运行。比如说，文件系统可能就是个运行在用户空间的常规程序，文件系统（file system）就跟echo，shell一样是个用户应用程序。还有其他的比如VM（virtual memory）应用程序，也作为一个普通的用户应用程序运行在user mode下。

![img](.assets/image%20(96).png)

某种程度上说，这是个不错的设计，因为在kernel中代码数量很少，代码少就意味着bug少，。

当然，这也有问题，假设我们需要让shell与file system交互，比如shell调用了exec，那就必须有某种方式接入到file system中。通常情况下，shell会发一个消息给kernel中的IPC模块，kernel会检查这条消息并知道这是要发给file system的

![img](.assets/image%20(85).png)

之后IPC将消息发给file system。file system完成工作之后会向IPC发一条消息，这是你的exec系统调用的结果，之后IPC模块再将这条消息发回给shell。

![img](.assets/image%20(97).png)

这里是典型的通过消息来实现传统的系统调用。现在，对于任何与file system的交互，都需要分别完成2次user space<->kernel space的跳转。相比之前的宏内核，shell与file system的交互只需要1次user space<->kernel space的跳转。所以微内核的跳转与宏内核的两倍。所以，通常来说，对微内核的一个挑战是如何取得更好的性能，这个挑战由两部分组成:

* 在user/kernel mode反复跳转带来的性能损耗。
* 微内核中，各个部分之间都很好的隔离开了，紧密的集成越少，那么就越难像宏内核那样实现一个紧耦合系统，例如在宏内核中，file system与virtual memory系统可以共享page cache。但是在微内核中，这种共享实现起来更难，进而导致微内核很难获取更好的性能。

我们这里介绍的有关宏内核和微内核的区别都特别的笼统。在实际中，这两种设计都存在，大多数桌面操作系统都是典型的宏内核系统，这是历史原因造成的。如果你运行需要大量内核计算的应用程序，例如在数据中心服务器上的操作系统，通常也是使用的宏内核，主要的原因是Linux提供了很好的性能。但是很多嵌入式系统，比如Minix,seL-4他们都是微内核设计。这两种设计都很受欢迎。如果你从0开始写一个内核的话，一个微内核设计是个不错的选择，但是一旦你有了类似Linux这样的宏内核设计，将它重写成一个微内核设计将会是个巨量的工作。而且这么做的动机也是不足的。因为人们更喜欢将时间花在实现新功能上，而不是花在重构内核上。

以这里是操作系统的两种主要设计。如你们所知的，XV6是一种宏内核设计，如大多数经典的Unix系统一样。但是在这个学期的后半部分，我们会讨论更多有关微内核设计的内容。

这里有人提问吗，email上讨论十分热烈，无人提问，谈下一话题。









